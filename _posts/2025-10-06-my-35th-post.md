---
layout: post
title:  PortSwigger Labs
date:   2025-08-15 21:00:00 +1000
categories: pentesting
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

### Overview

Dumping ground for all my thoughts whilst going through the PortSwigger labs. I'll handpick a few labs that I find interesting/relevant and discuss them here. 

Hopefully the below can act as a bit of a cheat sheet and summary for web app pentesting when complete.

### GraphQL
Query language and runtime for APIs, good alternative to RestAPI. GraphQL differs in that it has a single endpoint where the client specifies exactly what they need. Whereas for REST you tell it everything you don't need and it gives you the rest(pun not intended).

Determine whether the Web App uses GraphQL
``query{__typename}``

Common GraphQL endpoints
- ``/graphql``
- ``/api``
- ``/api/graphql``
- ``/graphql/api``
- ``/graphql/graphql``
- ``/v1``

Hit the any of the above endpoints with this in a POST request to try and return the __schema
``{"query":"query { __schema { types { name } } }"}``

Or even easier you can use ``clairvoyance`` after you identify the graphql endpoint on the site
``clairvoyance https://target.com/graphql``

The __schema is the keys to the kingdom. Essentially a blueprint of all the endpoint and what is accepted where.
- What queries, mutations and subscriptions exist
- Fields

``inQL`` is a burp extension that can be used to enumerate schemas and generate queries/mutations.

### Web Cache Deception
Web cache sits between the server and the client browser. When a static resource is requested the HTTP request first checks the cache to see if it exists. The cache has preset rules to determine what resources are stored. Web cache's can be exploited by sending a crafted link to your target user. The response of this request when clicked on is stored in cache. Then the attacker can navigate to the same URL and fetch the cached result, which can contain sensitive details if your web app is trash.

Btw I'm referring to CDN cache's and not your local browser cache!

``X-Cache`` header can indicate whether the response came from the cache.
- ``X-Cache: hit`` served from cache
- ``X-Cache: miss`` served from origin server
- ``X-Cache: dynamic`` served from origin server dynamically (response not suitable for caching)
- ``X-Cache: refresh`` cache content outdated and needs to be refreshed

Burp Scanner is helpful in detecting web cache vulnerabilitis caused by mapping discrepancies

``Cache-Control: max-age=30`` response stored in cache for 30 secs

Delimiter Discrepancies
Can use burp repeater with a list of common delimiters to determine which receive 200s on an endpoint you know works.
- `?` is used to separate the URL path from the string
- `?` is a delimiter in URI RFC
- `;` is a delimiter in Java
- `.` is a delimiter in Ruby Rails
- `%00` is a delimiter in OpenLiteSpeed Server

Occasionally the origin server and cache server will process delimiters differently. To prevent these attacks need to ensure that the web app server and CDN cache interpret URL paths the same.

### HTTP Request Smuggling
Modifies the way a webserver processes HTTP requests.

The attack relies on the attacker specifying different values for the ```Content-Length``` and ```Transfer-Encoding``` headers to trick the webserver into misinterpreting it's boundaries, allowing an attacker to nest another request within another.

By in large this vulnerability and technique is quite irrelevant as it only applies to HTTP/1. HTTP/2 has a mechanism for identifying the length of a request so is not vulnerable. However, a webserver may use HTTP/2 for it's front end and HTTP/1 for it's backend, which in turn would make them vulnerable.