---
layout: post
title:  "BrowserBuddy - Safe Browsing Browser Extension"
date:   2025-08-10 21:00:00 +1000
categories: project
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

BrowserBuddy - Chrome Extension. 

A browser extension that blocks dodgy JavaScript from ruining your browsing experience. 

With Clickfix prompts on the rise, malicious browser extensions and drive by downloads tearing apart the real OS (the browser) I thought up this idea.

This by no means is something new. However, the scope is kind of endless with this. The idea is too slowly build this out and see where it goes.

It'll be open-source so anyone can clone and get into it. I think there is a bit of a gap between NoScript and a BDR extension. Neither are very attractive for a regular user. NoScript for the ultra paranoid and BDR for enterprise browsers trying to protect uneducated employees. But what will the average user use?

BrowserBuddy! (ofc)

## Basic Functionality Features

These will be added to overtime.

### BrowserBuddy Toggle

Functionality to be toggled on/off 

![Stage 1](/images/browser_buddy_off.PNG)

![Stage 2](/images/browser_buddy_on.PNG)

### Exclude Domains from BrowserBuddy (DONE)

To avoid breaking website functionality browserbuddy allows users to exclude domains.

Here is an example of me trying to copy some text from Cyberchef.

![Stage 1](/images/browser_buddy_block.PNG)

As you can see it doesn't work!

So let's create an exclusion.

![Stage 1](/images/browser_buddy_exclusion.PNG)

We whack our domain into the box above and hit the magic button.

![Stage 1](/images/browser_buddy_exclusion_clicked.PNG)

As you can see the exclusion has been created. Now let's test it.

![Stage 1](/images/browser_buddy_copy_works.PNG)

Now I can use CyberChef without having to turn the extension off.

These exclusions are saved locally (chrome.storage.local). Therefore, when users restart there browsers the exclusion list remains. 

## Security Features

These stop all the bad stuff. The interesting features!

### Blocking JavaScript Clipboard APIs (DONE)

First successful addition to this is the blocking of JS Clipboard APIs. 

There are two JS APIs that trigger this. Both of them suck
- navigator.clipboard.writeText()
- document.execCommand()

Essentially I have blocked the 'programmatic' copy to a user's clipboard. 

What can still happen: 
- Ctrl+C 
- Right click --> Copy 

What can't happen:
- Webpages copying text automatically to clipboard using JS APIs
- User cannot click a copy button on a website

So business impact? Sounding real corporate. Users unable to interact with copy buttons on websites.

To demonstrate the functionality I'll boot up a live Clickfix prompt and see how BrowserBuddy behaves.

1. Navigate to ClickFix site with BrowserBuddy installed

![Stage 1](/images/browser_buddy_clickfix_stop.PNG)

2. BrowserBuddy blocks the JS programmatic copy=======

![Stage 2](/images/browser_buddy_clickfix_popup.PNG)

3. BrowserBuddy prints the command to the log

![Stage 3](/images/browser_buddy_log.PNG)

### Blocking Push Notifications (DONE)

I recently wrote an article on a new type of Cloudflare Clickfix (link here). In summary I found the prompt was subscribing browsers to push notifications. These subscriptions we're then being sold off for crypto on the threat actors website. 

Anywho, got me thinking I should add this as a feature. Because honestly, when is this used legitimately?

The JS API allowing this functionality is ``Notification.requestPermission()``

![Stage 3](/images/push_example.PNG)

That API creates the allow or block popup above.

Now lets give it a go, with BrowserBuddy enabled.

![Stage 3](/images/notification_blocked.PNG)

As we can see it's blocked. 

Now, push notifications are used legitimately by many websites. So we can create an exclusion in browser buddy so functionality isn't broken. 

### Blocking RPC Calls to prevent Ether Hiding delivery techniques (Development)

Most of the dodgy ether hiding payloads are pulled by using ``eth_call``. This makes an RPC call to a smart contract on the blockchain, which is used to store obfuscated code that contains a payload/command . ``eth_call`` is read only, so it's free and doesn't cost any gas when it is used. Gas refers to the cost that is incurred as a "fee" when making transactions on the blockchain.

Anyhow, this will break a bunch of stuff if I straight up block this. So instead I'll monitor the ``eth_call`` response for obfuscated replies. Replies with high entropy will be blocked. This could cause FPs so I'll have an option to turn it on/off. I've added the entropy value as 3. 

This function will break anyone that has a browser extension crypto wallet. But to be completley honest, if you have crypto stored in browser extensions it kind of deserves to be stolen.

### Block file downloads that masquerade as other extensions (Development)

File downloads that masquerade as other extensions (e.g. .exe.pdf)

Quick win, but still relevant. 

This regex ``/\.[^.\s]+?\.[^.\s]+$/`` will detect any filename that has two extensions.

I can apply this regex to any download and delete it if it has two extensions.

### Block typosquatting domains (Development)

Detects and blocks typosquatting domains (e.g paypa1.com).

So, I'm going to store a ``.json`` list of the most common typosquatted domains in ``chrome.storage.local``. I'll use regex to check for common typosquatting domains.

I'll apply regex to look for:
- Repeated characters
- Numeric prefixes
- Inserted hyphens

But, I'll also add a check for typosquatted TLD domains. E.g. Facebook.com as Facebook.help

Here's how the flow will work
1. User visits facebooook.com
2. Extension checks to see if facebooook.com exists on the .json list
3. If it does not it then the extension applies regex and other pattern matching methods to each domain in my .json list and checks if it matches facebooook.com
4. If it does. It blocks the request. If it does not, it allows access to that page!

Simple, but yet, effective. Typosquatting domains are less common as most of them are taken up and have a bad reputation on VT, therefore, blocked by proxy pretty easy. However, in my list I'll include lots of good domains. For example, recently ``npmjs.help`` was used to typosquat an NPM package dev which resulted in a large supply chain attack. So, it's still relevant imo.

### EvilGinx Phishing Kit Identification (Development)

The idea here is for the browser to detect EvilGinx being used, perhaps from the html structure. Then as a result, block the page.

### Domain reputation checker (Unlikely without six years of dev work)

The idea: 
- This function fetches an updated list of current threats from my MISP server. If the user visits any of them. The request will be blocked. My MISP server will provide the most current threats. The extension will call out to my MISP API once every hour for a new list. This list will contain no more than 5000 domains. As that is the limit provided for the declarativeNetRequest API which will be used for this.

Constraints:
- Unfortunately, this requires me to get my MISP server up and going again. Which isn't cheap.. Thanks Jeff.
- 5000 domains is going to be pretty ineffective as it's a small list.

Solutions:
- Not sure tbh