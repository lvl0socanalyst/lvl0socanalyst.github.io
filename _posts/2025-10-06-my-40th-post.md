---
layout: post
title:  Common JWT Attack Techniques
date:   2026-01-11 21:00:00 +1000
categories: pentesting
---

## Overview

Explanation of JWTs and common attack techniques.

### What is a JWT?
A JSON Web Token (JWT) is a unique string made up of 3 parts: A header, a payload and a signature.

Header (green) - Contains token metadata such as signing algorithm and signing key id
Payload (white) - Contains claims, which are pieces of information about the user and the token
Signature (blue) - Created by signing header and payload with signing key. Ensuring token integrity!

The dot seperates the header, payload and signature in the JWT.

![Everyone](/images/jwt.PNG)
- As you can see you are able to decode the header and payload without knowing the signing key. You can modify these as you please. However, the web application will sign the JWT with it's stored signing key and compare the signatures. If they are different, the request is not accepted.

### Cracking JWT Signing Key using Hashcat

Quite a relevant attack. This attack is possible if the developer who has set up the configuration uses a generic signing key. Thus, allow it to be bruteforced from a word list.

Hashcat takes a JWT string and tries to sign the header and payload block with every key on the word list until it matches the signature. Thus, finding the signing key. Now an attacker knows the signing key they create/modify a JWT payload and send it to the web app. The web app then takes the JWT header and payload signs it using the stored signing key, which createa a signature. It then compares the signature with the signature sent in the POST request from the attacker. Because they both used the same signing key, the signature block is the same, therefore, the JWT is accepted! 

As JWT is often used for authentication and authentication an attacker compromising a signing key isn't ideal.

1. Take a JWT from a POST request in and save to a .txt (jwt.txt)
```JavaScript
eyJraWQiOiJjNWI4ZDZiZS1mM2NhLTQxZjktYTM0Yi02OGFiMzFiMzdjYzMiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2ODQ3NTY4MCwic3ViIjoid2llbmVyIn0.qbEcMv928ua4S0j4q4kvobl7Ev74oDBuvER78OtrhbA
```
2. Boot up Kali and Hashcat
3. Pull down JWT signing key wordlist from git:
```bash
curl -O https://raw.githubusercontent.com/wallarm/jwt-secrets/refs/heads/master/jwt.secrets.list
```
4. Run the following command:
```bash
hashcat -a 0 -m 16500 jwt.txt jwt.secrets.list --show
```
- -a 0 = Attack mode (straight attack)
- Specifies attack type 16500 = JWT
- Specifies JWT token which is stored in 'jwt.txt'
- Specifies wordlist 'jwt.secret'
5. If successful, it will return the signing key. In my case it is 'secret1'
6. Open Burp Decoder up --> Convert signing key to B64
7. Go to JWT Editor --> New Symmetric Key --> Generate Key --> Modify 'k' value to your B64 encoded signing key
![Everyone](/images/sym_key.PNG)
8. Open up Burp Repeater with a POST request with a JWT token.
9. Click on 'JSON Web Token' tab
10. Modify 'sub' value to intended value. In this case it was 'administrator' as the JWT token was used in a POST request to login a user.
11. Sign your new JWT with the signing key we created in the previous steps. 
![Everyone](/images/signing.PNG)
12. Hit Send
13. Right Click --> Open response in browser --> Copy and Paste
14. Note - You have to repeat the signing process for every request you send.