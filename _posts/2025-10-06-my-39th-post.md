---
layout: post
title:  Prototype Pollution - Deep Dive with Practical Labs
date:   2025-12-23 21:00:00 +1000
categories: pentesting
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Came across this style of web app attack and thought I'd deep-dive it. It's quite interesting as it exploits a fundamental vulnerability in how JavaScript creates and interprets objects.

Prototype pollution enables an attacker to add properties to global object prototypes, which are able to be inherited by user-defined objects.

### JavaScript Objects

An object is JS is a "data structure used to store collections of related data and functionality".

Defining an Object
```javascript
const walter = {type:"Lvl0", model:"Noob"}
```
- Defines the object "walter" with the properties "type" and "model" with their respective values.

### Prototypes

A prototype is a mechanism that allows objects to inherit properties and methods from other objects.

By default every object in JavaScript inherits properties from their prototype.
```javascript
Object.prototype
```
By default the above is the top-level prototype for most objects

### Prototype Pollution

Prototype pollution becomes exploitable when an application reads a property without ensuring it is an own property.
```javascript
let user = {};
```
The above object is created without setting values for any of it's properties.

Through poking around the attacker has discovered that the object above contains a boolean property called "isAdmin". However, as we can see it is not defined ("true" or "false") when the object is created.

The object is created without defining isAdmin, so property lookup falls back to the prototype chain. If an attacker can add isAdmin: true to Object.prototype, any object that does not define its own isAdmin property will inherit it.

Three core terms when exploiting prototypes:
- Source: Where an attackers input enters the application. This is usually a vulnerable POST method. 
- Sink: Vulnerable operation allowing for prototype pollution (Unsafe object merging, recursive assignments) 
- Gadget: Code using the polluted property in a dangerous way.

## Client Side Prototype Pollution

The malicious code is ran on the user's browser not the server!

### DOM XSS via an client-side prototype pollution
The following prototype pollution leverages a DOM XSS exploit and delivers it to the end user.

DOM Invader is used as an semi-automatic tool to discover client-side prototype pollution vulnerabilities. 

You can enable on your Burp browser by: 
- Clicking on extensions top right --> Burp --> Enabling DOM Invader --> F12 to pull up Dev Tools --> Last tab is DOM Invader.

![Everyone](/images/proto.PNG)

The result tells us the following:
- The search function allows us to add a value to ```__proto__```

When we inspect the code for the JS for this page we can see this more clearly.

```javascript
async function searchLogger() {
    //deparam() parses URL parameters into an object
    //Does not protect against __proto__, constructor or prototype
    let config = {params: deparam(new URL(location).searchParams.toString())};

    //GADGET
    //Config does not define transport_url as an own property.
    //Therefore, by default JavaScript will look up the prototype chain.
    //It will be fetched from Object.prototype.transport_url (polluted by us)
    if(config.transport_url) {
        //SINK
        //Polluted value is loaded as a script.
        //Therefore, allowing for attacker-controlled JavaScript.
        let script = document.createElement('script');
        script.src = config.transport_url;
        document.body.appendChild(script);
    }
    
    if(config.params && config.params.search) {
        await logQuery('/logger', config.params);
    }
}
```
So let's hit "Scan for Gadgets" and see if DOM Invader can pick up the gadget as well!

![Everyone](/images/dom_proto.PNG)

As we can see it has.
- "Script.src" can be polluted through "transport_url"

So let's hit exploit!

![Everyone](/images/popup.PNG)

Boom pop up client-side! Awesome. 

This is what our URL params looked like:

"web-security-academy.net/?search=tets&```__proto__```[transport_url]=data%3A%2Calert%281%29"
- We can see that we have set the ```__proto__``` value for transport_url as data:,alert(1) (un-URL encoded)

## Server Side Prototype Pollution

The malicious code is ran on the server not the user's browser!

Server-side prototype pollution is far more likely to break stuff and it can be difficult to identify whether or not you we're successful!

### Privilege escalation via server-side prototype pollution

Below is a HTTP POST request that sends object data via JSON to the server about us (wiener). 

![Everyone](/images/orig.PNG)

In the response we can also see some additional fields. Notably ```isAdmin```. The response is also sent in JSON.

So let's try to append a property to the object.

![Everyone](/images/response.PNG)

Success! We've added a property called isVulnerable to the object. Therefore, we now have our "source"

Alright, we know the gadget allowing the prototype pollution is "isAdmin" so let's try to set the value of that to "true"

![Everyone](/images/success.PNG)

Woo hoo. Sorted. Let's refresh and we should now be admin on the webpage.

In summary. This worked because the value for "isAdmin" was not defined explicity for the user object. Therefore, it's value was inherited by ```__proto__``` (Object.prototype)

### Identifying sources without creating disruption server-side

There are a few ways you can test for prototype pollution without potentially breaking stuff.

HTTP error codes:
1. Find JSON POST method that is vulnerable.
2. Send a malformed JSON POST to it
3. Identify the custom "status" property. Try to change this value as unlikely to break the application if the pollution is successful.
4. Paste the above query.
```javascript
"__proto__": {
    "status":555
}
```
2. Send a malformed request
3. If the "status" code of 555 is observed. Indicates successful pollution.
4. Change value of intended property.

JSON Identation:
1. Find JSON POST method that is vulnerable.
2. Attempt to adjust the JSON indentation
```javascript
"constructor": {
    "prototype": {
        "json spaces":10
    }
}
```
OR
```javascript
"__proto__": {
    "json spaces":10
}
```
3. Check the Raw HTTP response and see whether the identation has changed.
4. If so, it is vulnerable and you can try and change the value of the property you want.

### Preventing prototype pollution

1. Prevent an object from inheriting properties
```javascript
let myObject = Object.create(null);
Object.getPrototypeOf(myObject); 
```
- Therefore, by default the object will look above to prototypes for property values.

2. Prevent changes to prototype objects
Invoking Object.freeze() method on an object ensures it's properties and values can no longer be modified. Therefore, you can apply this to a prototype.
```javascript
Object.freeze(Object.prototype);
```

3. Sanitise property keys
Prevent an attacker from injecting keys such as ```__proto__``` by creating an allowlist of permitted keys. 