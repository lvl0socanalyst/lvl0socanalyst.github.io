---
layout: post
title:  Prototype Pollution
date:   2025-12-23 21:00:00 +1000
categories: pentesting
---

<style>
  body { font-size: 16px; }
  body {font-family: 'Inter', sans-serif}
  h1 { font-size: 19px !important; }
  h2 { font-size: 17px !important; }
  h3 { font-size: 15px !important; }
</style>

## Overview

Came across this style of web app attack and thought I'd deep-dive it. It's quite interesting as it exploits a fundamental vulnerability in how JavaScript creates objects.

Prototype pollution enables an attacker to add properties to global object prototypes, which are able to be inherited by user-defined objects.

### JavaScript Objects

An object is JS is a "data structure used to store collections of related data and functionality".

Defining an Object
```javascript
const walter = {type:"Lvl0", model:"Noob"}
```
- Defines the object "walter" with the properties "type" and "model" with their respective values.

### Prototypes

A prototype is a mechanism that allows objects to inherit properties and methods from other objects.

By default every object in JavaScript inherits properties from their prototype.
```javascript
Object.prototype
```
By default the above is the top-level prototype for most objects

### Prototype Pollution

Prototype pollution becomes exploitable when an application reads a property without ensuring it is an own property.
```javascript
let user = {};
```
The above object is created without setting values for any of it's properties.

Through poking around the attacker has discovered that the object above contains a boolean property called "isAdmin". However, as we can see it is not defined ("true" or "false") when the object is created.

The object is created without defining isAdmin, so property lookup falls back to the prototype chain. If an attacker can add isAdmin: true to Object.prototype, any object that does not define its own isAdmin property will inherit it.

Three core terms when exploiting prototypes:
- Source: Where an attackers input enters the application. This is usually a vulnerable POST method. 
- Sink: Vulnerable operation allowing for prototype pollution (Unsafe object merging, recursive assignments) 
- Gadget: Code using the polluted property in a dangerous way.

## Client Side Prototype Pollution


### DOM XSS via an client-side prototype pollution
The following prototype pollution leverages a DOM XSS exploit and delivers it to the end user.

DOM Invader is used as an semi-automatic tool to discover client-side prototype pollution vulnerabilities. 

You can enable on your Burp browser by: 
- Clicking on extensions top right --> Burp --> Enabling DOM Invader --> F12 to pull up Dev Tools --> Last tab is DOM Invader.

![Everyone](/images/proto.PNG)
The result tells us the following
- The search function allows us to add a value to "__proto__"

When we inspect the code for the JS for this page we can see this more clearly.

```javascript
async function searchLogger() {
    //deparam() parses URL parameters into an object
    //Does not protect against __proto__, constructor or prototype
    let config = {params: deparam(new URL(location).searchParams.toString())};

    //GADGET
    //Config does not define transport_url as an own property.
    //Therefore, by default JavaScript will look up the prototype chain.
    //It will be fetched from Object.prototype.transport_url (polluted by us)
    if(config.transport_url) {
        //SINK
        //Polluted value is loaded as a script.
        //Therefore, allowing for attacker-controlled JavaScript.
        let script = document.createElement('script');
        script.src = config.transport_url;
        document.body.appendChild(script);
    }
    
    if(config.params && config.params.search) {
        await logQuery('/logger', config.params);
    }
}
```
So let's hit "Scan for Gadgets" and see if DOM Invader can pick up the gadget as well!

![Everyone](/images/dom_proto.PNG)

As we can see it has.
- "Script.src" can be polluted through "transport_url"

So let's hit exploit!

![Everyone](/images/popup.PNG)

Boom pop up client-side! Awesome. 

This is what our URL params looked like:

"web-security-academy.net/?search=tets&__proto__[transport_url]=data%3A%2Calert%281%29"
- We can see that we have set the __proto__ value for transport_url as data:,alert(1) (un-URL encoded)

## Server Side Prototype Pollution


### Preventing prototype pollution